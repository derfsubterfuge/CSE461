package edu.uw.cs.cse461.sp12.OS;

import java.io.FileInputStream;
import java.net.InetAddress;
import java.util.Properties;
import java.util.Timer;
import java.util.TimerTask;

import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.CommandLineParser;
import org.apache.commons.cli.HelpFormatter;
import org.apache.commons.cli.Options;
import org.apache.commons.cli.PosixParser;
import org.json.JSONException;
import org.json.JSONObject;

import edu.uw.cs.cse461.sp12.OS.NameManagerBase.NameException;
import edu.uw.cs.cse461.sp12.OS.NameManagerBase.NameRecord;
import edu.uw.cs.cse461.sp12.util.Log;

/**
 * Protocol: Based on RPC.  The calls:
 * <p>
 * Request:  method: "register" 
 *           args: 
 * <br>Response:  void
 * <p>
 * Fetch all records (for all apps) for a specific host.
 * Request:  method: "fetchall"
 *           args:  {host: hostname}
 * <br>Response:  [ [appname, port, authoritative], ...]
 *
 * <pre>
 * app:"ddns" supports RPC calls:
 *     register( {host: hostname,  ip: ipaddr,   port: portnum} ) => { status: "OK" } or errormsg
 *     resolve( { host: hostname } ) => { host: repeats hostname, ip: ip address, authoritative: boolean } ) or errormsg
 *     listchildren() => { hosts: [hostname 1, hostname 2, ...] }  [returns just names, not full records]
 * </pre>
 * 
 *  * @author zahorjan
 *
 */
public class DDNSService extends RPCCallable {
	private static String TAG="DDNSService";
	public static final char NAMESEP = '.';
	
	private Timer mTimer;  // to periodically register with parent
	private long mCacheTTL;
	
	private RPCCallableMethod<DDNSService> register;
	private RPCCallableMethod<DDNSService> resolve;
	private RPCCallableMethod<DDNSService> listchildren;
	
	@Override
	public String servicename() {
		return "ddns";
	}
	
	/**
	 * Try to keep straight when we have a fully qualified name, and when we may not,
	 * using the compiler's type checking system.
	 * <p>
	 * Except for the root, a FullName is an absolute name ending with a '.'.
	 * The name of the root is the empty string, "".
	 * <p>
	 * Example: FullName("a.b.c") is "a.b.c.".
	 * <br>Example: FullName("a.b.c.") is "a.b.c.".
	 * <br>Example: FullName(".a.b.c.") is "a.b.c.".
	 * <br>Example: FullName(".") is "".
	 * @author zahorjan
	 *
	 */
	public static class FullName {
		private static final String TAG="FullName";
		private String delegate;
		/**
		 * Deals with optional trailing '.', by applying one if needed.  The root name, "", never has a dot.
		 * All other names are of form "a.b.c.".
		 * @param name
		 * @return
		 */
		public FullName(String name) {
			delegate = name;
			if ( delegate == null ) return;
			if ( delegate.isEmpty() || delegate.equals(".")) delegate = "";
			else {
				if ( delegate.startsWith(".") ) delegate = delegate.substring(1);
				if ( !delegate.endsWith(".") ) delegate = delegate + ".";
			}
		}
		/**
		 * Given a valid name, returns parent of that name.  For example, given a.b.c.d, returns b.c.d.
		 * (Note that the name of the root is "").
		 * @param name  The name whose parent you want
		 * @return The name of the parent.  Returns the root ("") if argument name is null.
		 */
		public FullName parent() {
			if ( delegate == null ) return null;
			int index = delegate.indexOf(NAMESEP);
			if ( index < 0 || index >= delegate.length()-1  ) return new FullName("");
			return new FullName(delegate.substring(index+1));
		}
		
		/**
		 * Indicates whether or not this FullName is an immediate child of the parent.
		 * For example, a.b.c. is a child of b.c., but not of c.
		 * @param parent Suspected parent's name
		 * @return true if a direct child, false otherwise
		 */
		public boolean isChildOf(FullName parent) {
			if (delegate.length() < parent.toString().length()+2 ) return false;
			if ( !delegate.endsWith(parent.toString()) ) return false;
			String child = delegate.substring(0, delegate.length()-parent.toString().length());
			if ( !child.endsWith(".") || child.equals(".") ) return false;
			child = child.substring(0,child.length()-1);
			if ( child.indexOf('.') >= 0 ) return false; // it's an ancestor, but not a child
			return true;
		}
		public String toString() {
			return delegate;
		}
	}

	//------------------------------------------------------------------------
	// Utility classes

	public class DDNSException extends Exception {
		private static final long serialVersionUID = 1L;
		public DDNSException(String msg) { super(msg); }
	}

	public enum AddressType {
		HOST {
			@Override
			public String toString() { return "host"; }
		},
		RPC {
			@Override
			public String toString() { return "rpc"; }
		},
		NEGATIVE {
			@Override
			public String toString() { return "NEGATIVE"; }
		},
		EMPTY {
			@Override
			public String toString() { return "EMPTY"; }
		}
	};
	
	/**
	 * Utility class representing a single entry in the ddns cache.
	 * <p>
	 * Fields:
	 * <ul>
	 * <li>tag - A string annotation (usually "host:type", but can be arbitrary)
	 * <li>type - Primarily used to indicate "no record found," or else whether it was a host lookup or an app lookup
	 * <li>ip - The resolved ip, or null if none found.  (Note: The "ip" can be an Internet DNS name.  Java allows both where it allows either.)
	 * <li>port - The value field of the record.  When an app lookup is performed, it's the port.  When a host lookup is done, it's null.
	 * <li>authoritative - If true, indicates that entry will never be expired from the cache
	 * </ul>
	 * @author zahorjan
	 *
	 */
	public class AddressRecord {		
		public String tag;
		public AddressType type;  
		public String ip;
		public String port;
		public boolean authoritative;

		public AddressRecord(String tagStr) {
			tag = tagStr;
			type = AddressType.EMPTY;
			ip = null;
			port = null;
			authoritative = false;
		}
		public String toString() {
			String result = tag + " -> Type: " + type;
			if (type == AddressType.HOST || type == AddressType.RPC ) {
				result += " IP: " + ip;
				if  (type == AddressType.RPC ) result += " Port: " + port;
				result += " Auth: " + (authoritative?"1":"0");
			}
			return result;
		}
	}

	//------------------------------------------------------------------------

	/**
	 * Constructor.  Registers the system RPCServerSocket with the parent as
	 * this host's ip address.  Registers the root server and itself in the
	 * local name cache.
	 * @throws DDNSException
	 */
	DDNSService() throws DDNSException {
		
		NameManager manager = null;
		try {
			mTimer = new Timer();
			
			manager = new NameManager();
			Log.d(TAG, "created NameManager");

			//--------------------------------------------------------------
			// let me know where I am
			//--------------------------------------------------------------

			RPCService rpcService = (RPCService)OS.getService("rpc");
			String myPort = Integer.toString(rpcService.localPort());
			Log.d(TAG, "myPort = " + myPort);
			//TODO: This code throws an exception on Anroid 4.0
			String myIP = InetAddress.getLocalHost().getHostAddress();
			Log.d(TAG, "myIP = " + myIP);

			FullName myFullHostname = new FullName(OS.hostname());
			manager.write( myFullHostname, AddressType.HOST.toString(), myIP, true);
			manager.write( myFullHostname, AddressType.RPC.toString(), myPort, true);

			// export methods via the rpc service
			register = new RPCCallableMethod<DDNSService>(this, "_register");
			resolve = new RPCCallableMethod<DDNSService>(this, "_resolve");
			listchildren = new RPCCallableMethod<DDNSService>(this, "_listchildren");

			rpcService.registerHandler(servicename(), "register", register );
			rpcService.registerHandler(servicename(), "resolve", resolve );
			rpcService.registerHandler(servicename(), "listchildren", listchildren );
			
			//--------------------------------------------------------------
			// start up cache cleaning thread
			//--------------------------------------------------------------

			String ttlStr = OS.config().getProperty("ddns.cachettl");
			try {
				mCacheTTL = Integer.parseInt(ttlStr);
				if ( mCacheTTL < 60 ){
					Log.w(TAG, "Minimum cache ttl is 60 seconds.  Resetting value from config file.");
					mCacheTTL = 60;
				}
			} catch (Exception e) {
				Log.e(TAG, "ADVISORY: Invalid or missing ddns.cachettl property in config file");
				mCacheTTL = 60;  // default is 1 minutes
			}
			mTimer.scheduleAtFixedRate( new TimerTask() {
												public void run() {
													NameManager manager = null;
													try {
														manager = new NameManager();
														manager.deleteNonAuthoritativeOlderThan(mCacheTTL);
													} catch (Exception e) {
														Log.e(TAG, "Couldn't clean cache");
													} finally {
														if ( manager != null ) manager.discard();
													}
												}
				                        }, 
				                        1000 * mCacheTTL,
				                        1000 * mCacheTTL
									  );

			Log.wtf(TAG, "Starting ddns service for '" + OS.hostname() + "' on port " + myPort);

			//--------------------------------------------------------------
			// the following aren't done on the root.  (If I'm root, I just registered myself...)
			//--------------------------------------------------------------
			
			if ( myFullHostname.toString().isEmpty() ) {
				// dump state of db
				Log.i(TAG, manager.toString());
				return;
			}

			//--------------------------------------------------------------
			// register root host
			//--------------------------------------------------------------

			FullName rootFullName = new FullName("");
			
			String rootHost = OS.config().getProperty("ddns.rootserver");
			if ( rootHost == null ) throw new DDNSException("DDNSAgent.DDNSAgent: no rootserver in config file");
			manager.write(rootFullName, AddressType.HOST.toString(), rootHost, true);

			String rootPort = OS.config().getProperty("ddns.rootport");
			if ( rootPort == null ) throw new DDNSException("DDNSAgent.DDNSAgent: no rootddnsport in config file");
			manager.write(rootFullName, AddressType.RPC.toString(), rootPort, true);

			// dump state of db
			Log.i(TAG, manager.toString());
			
			//--------------------------------------------------------------
			// periodically let my parent know where I am
			//--------------------------------------------------------------
			
			mTimer.scheduleAtFixedRate(new TimerTask() {
				public void run() {
					try {
						FullName myFullHostname = new FullName(OS.hostname());
						String myPort = Integer.toString( ((RPCService)OS.getService("rpc")).localPort());
						String myIP = InetAddress.getLocalHost().getHostAddress();
						FullName parent = myFullHostname.parent();
						AddressRecord parentAddress = resolve( parent.toString() );
						if ( parentAddress.type != AddressType.RPC ) throw new DDNSException("Can't resolve address of parent: " + myFullHostname.parent() +
																									" [" + parentAddress.type + "]");
						RPCCallerSocket socket = new RPCCallerSocket(parent.toString(), parentAddress.ip, parentAddress.port);
						socket.invoke(servicename(), "register", new JSONObject().put("host", OS.hostname())
																			 .put("ip", myIP)
																			 .put("port", myPort)
									 );
					} catch (Exception e) {
						Log.e(TAG, "ADVISORY: Caught exception while registering with parent:\n" + e.getMessage());
					}
				}
			},
			0L, (int)(mCacheTTL * 1000 * 0.8) );

		} catch (Exception e) {
			String msg = "Constructor caught exception: " + e.getMessage();
			Log.e(TAG, msg);
			throw new DDNSException(msg);
		} finally {
			if ( manager != null ) manager.discard();
		}
	}
	
	/**
	 * Called to end execution.  Specifically, need to terminate any threads we've created.
	 */
	public void shutdown() {
		mTimer.cancel();
	}
	
	//---------------------------------------------------------------------------
	// RPC callable routines

	/**
	*     register( {host: hostname,  ip: ipaddr,   port: portnum} ) => { status: "OK" } or errormsg
	* 
	* @param args
	* @return
	*/
	public JSONObject _register(JSONObject args) throws JSONException, NameException, DDNSException {
		Log.i(TAG, "_register(" + args + ")");
		
		// only fullnames go in the db
		FullName thisHost = new FullName(OS.hostname());
		FullName newHost = new FullName(args.getString("host"));
		
		// can register only direct descendants through the RPC interface
		if ( !newHost.isChildOf(thisHost) ) throw new DDNSException("Server " + args.getString("host") + " cannot be registered at " + OS.hostname());

		String ipaddr = args.getString("ip");
		String port = args.getString("port");
		
		Log.e(TAG, "ip = " + ipaddr + "  port = " + port);

		_register(newHost, ipaddr, port);

		return null;
	}

	/**
	 * This version is invoked via RPC.  (See versions of resolve() for documentation.)
	 * @param callArgs
	 * @return
	 */
	public JSONObject _resolve(JSONObject args) throws JSONException, DDNSException {
		Log.i(TAG, "_resolve(" + args + ")");
		JSONObject result = new JSONObject();

		String host = args.getString("host");
		if ( host == null ) throw new JSONException("Malformed call arguments: '" + args.toString() + "'");

		AddressRecord address = resolve(host);
		if ( address.type != AddressType.RPC ) throw new DDNSException("Can't resolve host '" + host + "'");
		result.put("host", host).put("ip", address.ip).put("port", address.port).put("auth", address.authoritative);

		return result;
	}
	
	public JSONObject _listchildren(JSONObject args) {
		Log.i(TAG, "_listchildren(" + args + ")");
		//TODO: implement
		return null;
	}
	
	// RPC callable routines
	//---------------------------------------------------------------------------

	//---------------------------------------------------------------------------
	// resolve routines
	/**
	 * Convenience wrapper for the other resolve for clients who don't have a NameManager handy.
	 * Creates a NameManager, invokes resolve(NameManager...) with it, then discards it.
	 * <p>
	 * See resolve(NameManager...) for details.
	 */
	public AddressRecord resolve(String host) {
		Log.d(TAG, "Resolve(" + host + ")");
		return resolve(host, AddressType.RPC);
	}
	
	/**
	 * Resolves a host name to a fully qualified address of the RPC service on that host.
	 * @param manager  The NameManager to use
	 * @param host The host name (e.g., "jz.cse461")
	 * @param app The app name (e.g., "ddns")
	 * @return An AddressRecord.  The type field will be AddressType.EMPTY if resolution encounters an unrecoverable error.
	 *          It will be AddressType.NEGATIVE if the address is (recently) known to be unresolvable. Otherwise, it will be 
	 *          a resolved address with type AddressType.APP.
	 */
	public AddressRecord resolve(NameManager manager, String host) {
		Log.d(TAG, "resolve(manager, " + host + ")");
		return resolve(manager, host, AddressType.RPC);
	}
	
	/**
	 * 
	 * @param host
	 * @param type
	 * @return
	 */
	public AddressRecord resolve(String host, AddressType type) {
		Log.d(TAG, "resolve(" + host + ", " + type.toString() + ")");
		AddressRecord result;
		NameManager manager = null;
		try {
			manager = new NameManager();
			result = resolve(manager, host, type);
		} catch (Exception e ) {
			result = new AddressRecord(host + ":" + type);
		} finally {
			if ( manager != null ) manager.discard();
		}
		return result;
	}
	
	/**
	 * Resolves a host name to a fully qualified address of the specified type.
	 * @param manager  The NameManager to use
	 * @param host The host name (e.g., "jz.cse461")
	 * @param app The app name (e.g., "ddns")
	 * @return An AddressRecord.  The type field will be AddressType.EMPTY if resolution encounters an unrecoverable error.
	 *          It will be AddressType.NEGATIVE if the address is (recently) known to be unresolvable. Otherwise, it will be 
	 *          a resolved address with type AddressType.APP.
	 */
	public AddressRecord resolve(NameManager manager, String host, AddressType type) {
		Log.d(TAG, "resolve(manager, " + host + ", " + type.toString() + ")");
		AddressRecord address = new AddressRecord(host + ":" + type);
		
		// only fullnames go in the db
		FullName fullhost = new FullName(host);

		//Log.e("***resolve(" + host + ", " + app + ")");

		// first try a cached address, if there is one
		if ( _resolveFromCache(manager, fullhost, type, address)) return address;

		// if cached address didn't work, update cache and try again
		if ( _updateCache(manager, fullhost) && _resolveFromCache(manager, fullhost, type, address)) return address;

		// cache updating may have encountered a stale, cached record for some non-root ancestor.
		// Try resolution from root
		if ( _fullResolve(manager, fullhost, type, address) && _resolveFromCache(manager, fullhost, type, address) ) return address;

		// cache negative info
		try {
			if ( address.ip == null ) manager.write(fullhost, AddressType.HOST.toString(), null, false);
			if ( address.port == null ) manager.write(fullhost, type.toString(), null, false);
			// try to get the negative record
			_resolveFromCache(manager, fullhost, type, address);
		} catch (NameException e ) {
			// fatal error -- can't install new record(s)
		}

		return address;
	}
	
	/**
	 * This is a last resort resolver.  It starts at the root and works its way down.
	 * @param manager
	 * @param host
	 * @param type
	 * @param address
	 * @return
	 */
	private boolean _fullResolve(NameManager manager, FullName host, AddressType type, AddressRecord address) {
		Log.d(TAG, "_fullResolve(manager, " + host + ", " + type.toString() + ", address)");
		String delims = "[\\.]";
		String[] component = host.toString().split(delims);

		try {
			FullName name = new FullName("");
			// skip the root.  (host is a fullname.)
			for ( int i=component.length-2; i>=0; i++ ) {
				name = new FullName(component[i] + '.' + name);
				Log.e(TAG, "_fullResolve: working on '" + name + "'");
				address = resolve(manager, name.toString(), AddressType.RPC);
				if ( address.type != AddressType.RPC ) return false;
				if ( !address.authoritative ) throw new DDNSException("Encountered non-authoritative record for name '" + name + "'");
				manager.write(name, AddressType.HOST.toString(), address.ip, address.authoritative);
				manager.write(name, AddressType.RPC.toString(), address.port, address.authoritative);
			}
			return true;
		} catch (Exception e) {
			Log.e(TAG, "_fullResolve caught exception: " + e.getMessage());
		}
		return false;
	}

	/**
	 * Fetches all records about named host from authoritative server and
	 * then updates the local cache.
	 * @param manager  The NameManager to use
	 * @param host The host name
	 * @return true if records have been inserted into the name cache, false otherwise
	 */
	private boolean _updateCache(NameManager manager, FullName host) {
		Log.d(TAG, "_updateCache(manager, " + host + ")");
		FullName parent = host.parent();
		AddressRecord parentAddress = resolve(manager, parent.toString());  // reinvokes us recursively if parent map entry isn't cached

		// can try to contact parent ddns only if we managed to resolve its address
		try {
			if ( parentAddress.type != AddressType.RPC ) throw new DDNSException("No cached record for parent's IP");
			RPCCallerSocket sock = new RPCCallerSocket(parent.toString(), parentAddress.ip, parentAddress.port);
			JSONObject response = sock.invoke( servicename(), "resolve", new JSONObject().put("host", host) );
			
			//TODO:  Should we simply believe any old thing the remote server says?
			manager.write(host, AddressType.HOST.toString(), response.getString("ip"), response.getBoolean("auth"));
			manager.write(host, AddressType.RPC.toString(), response.getString("port"), response.getBoolean("auth"));

		} catch (Exception e) {
			// can't contact the server, or no reply received
			Log.e(TAG, "ADVISORY: invoke(ddns, resolve, host=" + host + ") failed:\n" + e.getMessage());
		} 

		return false;
	}

	/**
	 * 
	 * @param manager
	 * @param host
	 * @param type
	 * @param address
	 * @return  true if a record was found, false if no record
	 */
	private boolean _resolveFromCache(NameManager manager, FullName host, AddressType type, AddressRecord address) {
		Log.d(TAG, "_resolveFromCache(manager, " + host + ", " + type.toString() + ", address)");
		// first try a cached address, if there is one
		NameRecord record;
		try {
			// fetch host record
			record = manager.readOneRecord(host, AddressType.HOST.toString());
			if ( record == null ) return false;
			address.ip = record.value;
			address.authoritative = record.authoritative;
			if ( address.ip == null ) address.type = AddressType.NEGATIVE;
			else if ( type == AddressType.HOST ) address.type = type;
			if ( type == AddressType.HOST ) return true;
			
			// fetch app record
			record = manager.readOneRecord(host, type.toString());
			if ( record == null ) {
				// Sanity check code: the root resolver should always be in the db
				if ( host.toString().isEmpty() ) Log.e(TAG, "resolve(" + host + ", " + type + "): Didn't find record, but it's root!");
				return false;
			}
			address.port = record.value;
			address.authoritative &= record.authoritative;
			if ( address.port != null ) address.type = type;
			else address.type = AddressType.NEGATIVE;
			return true;

		} catch (Exception e ) {
			// no cached value
			Log.e(TAG, "ADVISORY: _tryResolve caught exception: " + e.getMessage());
			return false;
		}
	}
	// resolve routines
	//---------------------------------------------------------------------------
	
	//---------------------------------------------------------------------------
	// register routines

	/**
	 * Update address mapping.  The interface allows only a host specification.
	 * The port given is implicitly for the RPC service on that host.
	 * 
	 * @param fullhost The name of the host for this mapping.
	 * @param ip  That host's IP address.
	 * @param port The port of the RPC service on that host.
	 */
	private void _register(FullName fullhost, String ip, String port) {
		Log.d(TAG, "_register(" + fullhost + ", " + ip + ", " + port + ")");
		NameManager manager = null;
		try {
			FullName myHost = new FullName(OS.hostname());
			// Only the entries for this host and for the root are authoritative - others
			// can change, and must be purged from the cache periodically.
			boolean auth = (fullhost.toString().isEmpty() || fullhost.equals(myHost));
			manager = new NameManager();
			manager.write(fullhost, AddressType.HOST.toString(), ip, auth);
			manager.write(fullhost, AddressType.RPC.toString(), port, auth);
			Log.d(TAG, manager.toString());
		} catch (Exception e) {
			Log.e(TAG, "_register caught exception " + e.getMessage());
		} finally {
			if ( manager != null ) manager.discard();
		}
	}
	// register routines
	//---------------------------------------------------------------------------
	
		
	/**
	 * The usual toString.
	 */
	public String toString() {
		StringBuilder sb = new StringBuilder();
		String currentName = OS.hostname();
		sb.append("Hostname: ");
		if ( currentName != null ) sb.append(currentName).append("\n");
		else sb.append("undefined\n");
		
		NameManager manager = null;
		try {
			manager = new NameManager();
			sb.append(manager.toString()).append("\n");
		} catch (Exception e) {
			sb.append("DDNSAgent.toString: caught exception: " + e.getMessage());
		} finally {
			if (manager != null) manager.discard();
		}
		return sb.toString();
	}

	/**
	 * A simple test driver that ends up dumping the current cached naming information.
	 * @param args
	 */
	public static void main(String[] args) {
		final String TAG="DDNSAgent.main";
		String configFilename = "config.ini";
		try {
			// This code deals with command line options
			Options options = new Options();
			options.addOption("f", "configfile", true, "Config file name (Default: " + configFilename + ")");
			options.addOption("h", "help", false, "Print this message");

			CommandLineParser parser = new PosixParser();

			CommandLine line = parser.parse(options, args);
			if ( line.hasOption("help") ) {
				HelpFormatter formatter = new HelpFormatter();
				formatter.printHelp(DDNSService.class.getName(), options );
				return;
			}
			if ( line.hasOption("configfile") ) configFilename = line.getOptionValue("configfile");

			// read config file data
			Properties config = new Properties();
			config.load(new FileInputStream(configFilename));

			OS.boot(config);

			DDNSService agent = (DDNSService)OS.getService("ddns");
			Log.e(TAG, agent.toString());

			// Resolve a host
			AddressRecord testAddress = agent.resolve(OS.hostname(), AddressType.HOST);
			Log.e(TAG, testAddress.toString());

			testAddress = agent.resolve(OS.hostname());
			Log.e(TAG, testAddress.toString());
			
			testAddress = agent.resolve("");
			Log.e(TAG, testAddress.toString());

			testAddress = agent.resolve(new FullName(OS.hostname()).parent().toString());
			Log.e(TAG, testAddress.toString());

			testAddress = agent.resolve("foo.jz.cse461");
			Log.e(TAG, testAddress.toString());

			testAddress = agent.resolve("foo.cse461");
			Log.e(TAG, testAddress.toString());

		} catch (Exception e) {
			Log.e(TAG, "DDNSAgent caught exception: " + e.getMessage());
		}
	}
}
