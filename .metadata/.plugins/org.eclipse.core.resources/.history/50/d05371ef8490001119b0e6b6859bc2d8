package edu.uw.cs.cse461.sp12.OS;

import java.io.IOException;
import java.util.HashMap;
import java.util.Set;
import java.util.Timer;
import java.util.TimerTask;

import org.json.JSONException;
import org.json.JSONObject;

import edu.uw.cs.cse461.sp12.OS.DDNSException.DDNSNoAddressException;
import edu.uw.cs.cse461.sp12.OS.DDNSException.DDNSNoSuchNameException;
import edu.uw.cs.cse461.sp12.OS.DDNSException.DDNSRuntimeException;
import edu.uw.cs.cse461.sp12.OS.DDNSRRecord.ARecord;
import edu.uw.cs.cse461.sp12.OS.DDNSRRecord.RRType;
import edu.uw.cs.cse461.sp12.OS.HTTPDService.HTTPProvider;
import edu.uw.cs.cse461.sp12.OS.OSLoadable.OSLoadableService;
import edu.uw.cs.cse461.sp12.util.Log;

public class DDNSResolverService implements OSLoadableService, HTTPProvider {
	private static String TAG="DDNSResolverService";
	
	private static final int DEFAULTCACHETTL = 120;
	private static final int MINIMUMCACHETTL = 30;
	private static final int DEFAULTCLEANINTERVAL = 65;
	private static final int MINIMUMCLEANINTERVAL = 10;

	private Timer mTimer;  // to periodically register with parent
	private long mCacheTTL;
	
	private HashMap<DDNSFullName, DDNSNode> mCache;
	
	private RPCCallableMethod<DDNSResolverService> resolve;
	
	@Override
	public String loadablename() {
		return "ddnsresolver";
	}
	
	/**
	 * Called to end execution.  Specifically, need to terminate any threads we've created.
	 */
	@Override
	public void shutdown() {
		if ( mTimer != null ) mTimer.cancel();
		mTimer = null;
	}
		
	@Override
	public String httpServe(String[] uriArray) {
		return toString();
	}
	
	public DDNSResolverService() throws DDNSException {
		mCache = new HashMap<DDNSFullName, DDNSNode>();
		mTimer = new Timer();
		
		//--------------------------------------------------------------
		// register root host
		//--------------------------------------------------------------

		String rootHost = OS.config().getProperty("ddns.rootserver");
		if ( rootHost == null ) throw new DDNSRuntimeException("DDNSAgent.DDNSAgent: no rootserver in config file");
		int rootPort;
		try {
			rootPort = OS.config().getInt("ddns.rootport");
		} catch (NoSuchFieldException e) {
			throw new DDNSRuntimeException("No ddns.rootport entry in config file");
		}
		// the node has a null password, meaning it can't be modified
		DDNSNode rootNode = new DDNSNode(DDNSFullName.ROOTNAME, null, new ARecord(rootHost, rootPort) );
		rootNode.record().setAuthoritative(true);
		addNode(rootNode);

		Log.d(TAG,  toString(""));
		
		//--------------------------------------------------------------
		// start up cache cleaning thread
		//--------------------------------------------------------------

		mCacheTTL = OS.config().getInt("ddnsresolver.cachettl", DEFAULTCACHETTL, MINIMUMCACHETTL, TAG);
		Log.d(TAG, "Cache ttl = " + mCacheTTL + " seconds");
		
		// we don't refesh our parent if we're the ddns root
		
		
		int cleanInterval = OS.config().getInt("ddnsresolver.cleaninterval", DEFAULTCLEANINTERVAL, MINIMUMCLEANINTERVAL, TAG);
		Log.d(TAG, "Clean interval = " + cleanInterval + " seconds");

		mTimer.scheduleAtFixedRate( new TimerTask() {
											public void run() {
												Log.d(TAG, "Resolver cleaning cache");
												try {
													synchronized(mCache) {
														Set<DDNSFullName> keySet = mCache.keySet();
														for ( DDNSFullName name : keySet ) {
															DDNSNode node = mCache.get(name);
															DDNSRRecord record = node.record();
															if ( record!=null && !record.authoritative() && record.ttl() < OS.now() ) {
																mCache.remove(name);
																Log.d(TAG, "\tRemoved cached node for " + name);
															}
														}
													}
												} catch (Exception e) {
													Log.d(TAG, "Couldn't clean cache");
												}
												Log.d(TAG, "Done cleaning: " + toString());
											}
			                        }, 
			                        1000 * cleanInterval,
			                        1000 * cleanInterval
								  );

	}

	DDNSNode addNode(DDNSNode node) {
		synchronized(mCache) {
			node.record().setTTL( OS.now() + mCacheTTL );
			mCache.put(node.name(), node);
		}
		return node;
	}
	
	/**
	 * Send a resolve request to the root.
	 * 
	 * @param host
	 * @return
	 * @throws DDNSException
	 */
	DDNSNode askRootDDNSService(DDNSFullName host, Integer resolveTTL) throws DDNSException {
		DDNSNode rootNode = _resolveToNode(DDNSFullName.ROOTNAME);
		return askDDNSService(host, rootNode.name(), (ARecord)rootNode.record(), resolveTTL);
	}
	
	/**
	 * Send resolve request to a remote DDNS service. 
	 * @param host
	 * @param ddnsNode
	 * @return
	 */
	DDNSNode askDDNSService(DDNSFullName host, DDNSFullName ddnsName, ARecord ddnsRecord, Integer resolveTTL ) throws DDNSException {
		//TODO: copy code from DDNSService for rpc resolve call
		
		if ( ddnsRecord.isNegative() ) throw new DDNSNoAddressException( ddnsName );
		
		JSONObject response;
		try {
			RPCCallerSocket socket = new RPCCallerSocket( host.toString(),
		                                                  ddnsRecord.ip(),
		                                                  ddnsRecord.port()
						                                );
			response = socket.invoke( "ddns", 
									  "resolve",
									  new JSONObject().put("host", host.toString())
									  				  .put("ttl", resolveTTL.intValue()-1)
						 			);
			String responseHost = (String)response.get("host"); 
			if ( responseHost==null || !responseHost.equals(host.toString()) )
				throw new DDNSRuntimeException("Requested name " + host + ", got response for name '" + responseHost + "'");
			if ( response.get("rr") == null ) throw new DDNSNoSuchNameException(host); // no such name exists

			ARecord addressRecord = (ARecord)DDNSRRecord.jsonObjectToRRecord(response);
			if ( addressRecord.isNegative() ) throw new DDNSNoAddressException( new DDNSFullName(responseHost) );
			return new DDNSNode( new DDNSFullName(responseHost), null, addressRecord);
			
		} catch (JSONException je) {
			
		} catch (IOException e) {
			throw new DDNSRuntimeException(e.getMessage());
		}

	}
	
	public DDNSRRecord resolve(String host) throws DDNSException {
		return resolve(new DDNSFullName(host));
	}
	
	ARecord resolve(DDNSFullName host) throws DDNSException {
		DDNSNode node = _resolveToNode(host);
		DDNSRRecord record = node.record();
		if ( record.type() == RRType.RRTYPE_A || record.type() == RRType.RRTYPE_SOA ) return (ARecord)record;
		//TODO: Is null ok?
		return null; // !!!!
	}
	
	/**
	 * Try to fetch ARecord info for name from the cache.
	 *
	 * @param host
	 * @return  ARecord for host, if one in the cache, null otherwise
	 */
	DDNSNode _resolveToNode(DDNSFullName host) throws DDNSException {
		Log.d(TAG, "resolve(" + host + ")");

		DDNSNode node = null;
		try {
			// fetch host record
			synchronized(mCache) {
				node = mCache.get(host);
			}
			if ( node != null )	return node;
		} catch (Exception e ) {
			Log.w(TAG, "ADVISORY: DDNSREsolverService::resolve(" + host + ") caught exception: " + e.getMessage());
		}

		// not in cache. Sanity check -- root entry should be there!
		if ( host.equals(DDNSFullName.ROOTNAME) ) throw new DDNSRuntimeException("Didn't find root server record in cache");
		
		// Perform a full resolution.
		// If there's a local resolver and host is a descendant, start with local ddns
		DDNSService ddns = (DDNSService)OS.getService("ddns");
		if ( ddns != null && host.isDescendantOf( ddns.soaName()) ) {
			DDNSNode resultNode = ddns.resolve(host); 
			return resultNode;
		}

		// If can't shortcut, start at root
		return ddns.resolve(host);
	}
	
	public void registerRelative(String relativeName, int port) throws IOException, DDNSException {
		//TODO: implement
		RPCService rpc = (RPCService)OS.getService("rpc");  // for getting
		if ( rpc == null ) {
			Log.w(TAG, "No rpc service.  Can't registerRelative(" + relativeName + ")");
			return;
		}
		
		DDNSFullName fullName = new DDNSFullName( relativeName + "." + OS.hostname());
		//TODO: what should password be here?
		DDNSNode newNode = new DDNSNode(fullName, null, new ARecord(rpc.localIP(), port));
		
		//TODO: now register this node with my DDNS server, which might not be local
//		DDNSService ddns = (DDNSService)OS.getService("ddns");
//		DDNSNode newNode = ddns.registerRelative(relativeName, rpc.localIP(), port);
//		addNode( newNode );
	}
	
	public String toString(String prefix) {
		StringBuilder sb = new StringBuilder();
		return _toString(sb, prefix).toString();
	}
	
	public StringBuilder _toString(StringBuilder sb, String prefix) {	
		synchronized(mCache) {
			for ( DDNSNode node : mCache.values() ) {
				sb.append("\n");
				node._toStringNoChildren(sb, prefix);
			}
		}
		return sb;
	}
}
