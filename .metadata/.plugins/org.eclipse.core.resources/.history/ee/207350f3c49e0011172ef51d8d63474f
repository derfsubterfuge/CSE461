package edu.uw.cs.cse461.sp12.OS;

import java.net.UnknownHostException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Timer;
import java.util.TimerTask;

import org.json.JSONException;

import edu.uw.cs.cse461.sp12.OS.DDNSException.DDNSNoAddressException;
import edu.uw.cs.cse461.sp12.OS.DDNSException.DDNSNoSuchNameException;
import edu.uw.cs.cse461.sp12.OS.DDNSException.DDNSRuntimeException;
import edu.uw.cs.cse461.sp12.OS.DDNSException.DDNSTTLExpiredException;
import edu.uw.cs.cse461.sp12.OS.DDNSNode.DDNSCacheNode;
import edu.uw.cs.cse461.sp12.OS.DDNSRRecord.ARecord;
import edu.uw.cs.cse461.sp12.OS.DDNSRRecord.CNAMERecord;
import edu.uw.cs.cse461.sp12.OS.DDNSRRecord.RRType;
import edu.uw.cs.cse461.sp12.OS.DDNSRRecord.SOARecord;
import edu.uw.cs.cse461.sp12.OS.DDNSServiceRPCStub.DDNSServiceRegisterStub;
import edu.uw.cs.cse461.sp12.OS.DDNSServiceRPCStub.DDNSServiceResolveStub;
import edu.uw.cs.cse461.sp12.OS.DDNSServiceRPCStub.DDNSServiceUnregisterStub;
import edu.uw.cs.cse461.sp12.OS.HTTPDService.HTTPProvider;
import edu.uw.cs.cse461.sp12.OS.OSLoadable.OSLoadableService;
import edu.uw.cs.cse461.sp12.util.Log;

public class DDNSResolverService implements OSLoadableService, HTTPProvider {
	private static String TAG="DDNSResolverService";
	
	private static final int DEFAULTCACHETTL = 120;

	private static final int DEFAULTPARENREFRESHINTERVAL = 600;  // 10 minutes
	private static final int MINIMUMPARENTREFRESHINTERVAL = 5;   //  5 seconds
	
	private String mDDNSServicePassword;
	private int mMaxServerTTL;  // maximum number of DDNS servers to visit for any one resolve request (or the like)
	
	private Timer mTimer;    // to periodically register with parent
	private long mCacheTTL;  // how long a cached node is kept in the cache, in seconds
	
	private NodeCache mCache;
	
	private DDNSCacheNode mRootServerNode;
	
	@Override
	public String loadablename() {
		return "ddnsresolver";
	}
	
	/**
	 * Called to end execution.  Specifically, need to terminate any threads we've created.
	 */
	@Override
	public void shutdown() {
		// if we're not the root, we need to unregister
		if ( !new DDNSFullName(OS.hostname()).equals(DDNSFullName.ROOTNAME)) {
			DDNSFullName name = new DDNSFullName(OS.hostname()); 
			try {
				unregister(name);
			} catch (DDNSNoAddressException e) {
				// this exception means an NS record was found and set to null, which is normal behavior
				if ( !e.args.get(0).equals(name.toString()) ) Log.w(TAG, "ADVISORY: NoAddressException on name " + e.args.get(0) + " unregistering " + name );
			} catch (Exception e) {
				Log.w(TAG, "ADVISORY: Caught exception while unregistering with parent:\n" + e.getMessage());
			}
		}
		// have to kill the timer after doing the unregister, in case the unregister ends up
		// caching something
		if ( mTimer != null ) mTimer.cancel();
		mTimer = null;
	}
		
	/**
p	 * Serves web pages.  The 0th element of uriArray is always null.
	 * The next element names this service ("ddnsresolver").  The optional third
	 * component is a name to be resolved before dumping the cache.
	 */
	@Override
	public String httpServe(String[] uriArray) {
		StringBuilder sb = new StringBuilder();
		sb.append("Host:  ").append(OS.hostname()).append("\n");
		if ( uriArray.length > 2 ) {
			sb.append("Resolving: ").append(uriArray[2]).append("\n");
			// third component
			ARecord result = null;
			try {
				result = resolve(uriArray[2]);
				sb.append("Got: [").append(result).append("]\n");
			} catch (Exception e) {
				sb.append("Got exception: ").append(e.getMessage()).append("\n");
			}
		}
		sb.append("\nCache contents:\n");
		_toString(sb, "");
		return sb.toString();
	}
	
	//-----------------------------------------------------------------------------
	//-----------------------------------------------------------------------------
	// Timer utility classes 
	
	public class CacheCleaner extends TimerTask {
		DDNSFullName key;
		CacheCleaner(DDNSFullName name) { key = name; }
		public void run() {
			mCache.deleteNode(key);
		}
	}
	
	/**
	 * Repeatedly registers a node that is in the cache, using the IP/port of that node.
	 * Must be able to:
	 *   - stop registering, if the node is removed from the cache
	 *   - keep trying, even when registration fails
	 *   - adapt its period based on lifetime information provided by the eventual server
	 *   
	 * @author zahorjan
	 *
	 */
	public class RegistrationKeepAlive extends TimerTask {
		DDNSFullName mName;
		RegistrationKeepAlive(DDNSFullName name) { mName = name; }
		public void run() {
			// Sanity check -- if the node is no longer in the cache, don't perform keep-alive.
			NodeCache.CacheElement element = mCache.readElement(mName);
			if ( element == null || element.mKeepAliveTask != this ) {
				cancel();
				return;
			}
			DDNSCacheNode node = element.mNode;
			ARecord aRecord = (ARecord)node.record();
			try {
				register(node.name(), aRecord.port());
			} catch (Exception e) {
				// failures are normal -- some parent name server is down.  Keep trying.
			}

		}
	}
	// Timer utility classes 
	//-----------------------------------------------------------------------------
	//-----------------------------------------------------------------------------
	

	//-----------------------------------------------------------------------------
	//-----------------------------------------------------------------------------
	// NodeCache class

	private class NodeCache {
		private int mCacheHits = 0;
		private int mCacheMisses = 0;
		private HashMap<DDNSFullName, CacheElement> mElementCache;

		class CacheElement {
			public DDNSCacheNode mNode;
			public TimerTask mKeepAliveTask;
			public TimerTask mCleanTask;
			CacheElement(DDNSCacheNode node) { mNode = node; mKeepAliveTask = null;	mCleanTask = null; }
		}
		
		NodeCache() { mElementCache = new HashMap<DDNSFullName, CacheElement>(); }
			
		/**
		 * Inserting a node that we want to cache forever - e.g., the address of this host.
		 * We delete any existing cache element, and create a new sticky element. 
		 * 
		 * @param node
		 * @param lifetime  The amount of time by which a keep alive must be registered
		 * @return
		 */
		synchronized private DDNSCacheNode addStickyNode(DDNSCacheNode node, int lifetime) {
			DDNSNode oldNode = deleteNode(node.name());
			CacheElement element = new CacheElement(node);
			element.mKeepAliveTask = new RegistrationKeepAlive(node.name()); 

			// the task will try to re-register.  If that fails, it won't re-add this node, so this keep alive needs to repeat.
			int keepaliveInterval = (int)(lifetime * 0.95);
			if ( keepaliveInterval <= MINIMUMPARENTREFRESHINTERVAL ) keepaliveInterval = MINIMUMPARENTREFRESHINTERVAL;
			mTimer.schedule( element.mKeepAliveTask, keepaliveInterval*1000); 
			mElementCache.put(node.name(), element);
			return node;
		}
		
		/**
		 * Inserting a node that we don't want to cache forever - just treat normally.
		 * If there is already a sticky node, we update it, but don't replace it.
		 * 
		 * @param node
		 * @return
		 */
		synchronized private DDNSCacheNode addNode(DDNSCacheNode node) {
			CacheElement element = mElementCache.get(node.name());
			if ( element != null ) {
				if ( element.mKeepAliveTask != null ) {
					// there's already a sticky node in the cache.  Update the node it points at and otherwise leave it alone.
					element.mNode = node;
					return node;
				}
				deleteNode(node.name());
			}

			// ttl==0 means don't cache anything (that isn't sticky)
			if ( mCacheTTL <= 0 ) return node;

			// okay, set up element for this node
			element = new CacheElement(node);
			element.mCleanTask = new CacheCleaner(node.name());
			mTimer.schedule( element.mCleanTask, (long)(mCacheTTL*1000));
			mElementCache.put(node.name(), element);
			return node;
		}

		private DDNSCacheNode readNode(DDNSFullName name) {
			CacheElement element;
			synchronized(this) {
				element = mElementCache.get(name);
			}
			if ( element == null || element.mNode == null ) {
				mCacheMisses++;
				return null;
			}
			mCacheHits++;
			return element.mNode;
		}
		
		synchronized private CacheElement readElement(DDNSFullName name) {
			return mElementCache.get(name);
		}

		/**
		 * Definitely deletes the node, whether sticky or not.
		 * @param name
		 * @return
		 */
		synchronized private DDNSCacheNode deleteNode(DDNSFullName name) {
			CacheElement element = mElementCache.remove(name);
			if ( element == null ) return null;
			if ( element.mCleanTask != null ) element.mCleanTask.cancel();
			if ( element.mKeepAliveTask != null ) element.mKeepAliveTask.cancel();
			return element.mNode;
		}
		
		synchronized public StringBuilder _toString(StringBuilder sb, String prefix) {
			sb.append(mCacheMisses).append(" misses\n")
			  .append(mCacheHits).append(" hits\n\n");
			List<DDNSFullName> names = new ArrayList<DDNSFullName>(mElementCache.keySet());
			Collections.sort(names);
			for ( DDNSFullName name : names ) {
				readNode(name)._toString(sb, prefix);
			}
			return sb;
		}
	}
	
	// NodeCache class
	//-----------------------------------------------------------------------------
	//-----------------------------------------------------------------------------
	
	public DDNSResolverService() throws DDNSException {
		mCache = new NodeCache();
		mTimer = new Timer();
		
		//--------------------------------------------------------------
		// See if I have a password
		//--------------------------------------------------------------

		mDDNSServicePassword = OS.config().getProperty("ddnsresolver.password");
		if ( mDDNSServicePassword == null ) {
			Log.w(TAG, "No valid ddnsresolver.password entry in config file.  Using null string password.");
			mDDNSServicePassword = "";  // try using no password
		}
		
		//--------------------------------------------------------------
		// establish resolution TTL
		//--------------------------------------------------------------
		
		mMaxServerTTL = OS.config().getInt("ddnsresolver.maxserverttl", 5, 1, 100, TAG);
		
		//--------------------------------------------------------------
		// remember the root host as an uncached cached node
		//--------------------------------------------------------------

		mRootServerNode= new DDNSCacheNode(DDNSFullName.ROOTNAME, new SOARecord(null, -1));
		mRootServerNode.setIsNegative(true);
		String rootHost = OS.config().getProperty("ddns.rootserver");
		if ( rootHost == null ) Log.e(TAG, "DDNSAgent.DDNSAgent: no rootserver in config file");
		else {
			try {
				int rootPort = OS.config().getInt("ddns.rootport");
				mRootServerNode = new DDNSCacheNode(DDNSFullName.ROOTNAME, new SOARecord(rootHost, rootPort) );
			} catch (NoSuchFieldException e) {
				Log.e(TAG, "No ddns.rootport entry in config file");
			}
		}

		//--------------------------------------------------------------
		// fetch cachettl info
		//		ddnsresolver.cachettl == 0 means don't cache.
		//--------------------------------------------------------------

		mCacheTTL = OS.config().getInt("ddnsresolver.cachettl", DEFAULTCACHETTL, 0, TAG);
		Log.d(TAG, "Cache ttl = " + mCacheTTL + " seconds");
		
		//--------------------------------------------------------------
		// Put our address in the local cache and arrange for keep-alives.
		//   We can't just call register at this point, because  our own
		//   DDNSService isn't yet running and we'll end up throwing an
		//   an error because register can't connect to it.
		//--------------------------------------------------------------
		
		if ( !new DDNSFullName(OS.hostname()).equals(DDNSFullName.ROOTNAME)) {
			RPCService rpcService = (RPCService)OS.getService("rpc");
			String myIP = null;
			try {
				myIP = rpcService.localIP();
			} catch (UnknownHostException e) {
				Log.e(TAG, "Can't determine my IP: " + e.getMessage());
			}
			DDNSCacheNode thisHostNode = new DDNSCacheNode( new DDNSFullName(OS.hostname()), new ARecord(myIP, rpcService.localPort()) ); 
			mCache.addStickyNode(  thisHostNode, 10 ); // try registering every 10 seconds or so, until successful 
		}
	}

	/**
	 * Unregisters a name.  
	 * @param name
	 * @throws DDNSException
	 */
	void unregister(DDNSFullName name) throws DDNSException, JSONException {
		mCache.deleteNode(name);
		DDNSServiceUnregisterStub callStub = new DDNSServiceUnregisterStub(name, mDDNSServicePassword);
		DDNSResultObject response = _serverIterate(callStub);
		if ( !response.mDone ) throw new DDNSRuntimeException("unregister didn't return done==true, but didn't throw exception");
	}
	
	/**
	 * Registers a name as being on this host (IP) at the given port.
	 * If the name already exists, update its address mapping.  If it doesn't exist, create it (as an ARecord).
	 * <p>
	 * Can't be public, because it uses our password.
	 * @param name
	 * @param ip
	 * @param port
	 * @throws DDNSException
	 */
	void register(DDNSFullName name, int port) throws DDNSException {
		
		// figure out ip for registration
		RPCService rpc = (RPCService)OS.getService("rpc");
		if ( rpc == null ) throw new DDNSRuntimeException("No rpc service available.  Can't register '" + name + "'");
		String ip;
		try {
			ip = rpc.localIP();
		} catch (UnknownHostException e) {
			throw new DDNSRuntimeException("register(" + name + ") caught UnknownHostException: " + e.getMessage());
		}
		
		try {
			DDNSServiceRegisterStub callStub = new DDNSServiceRegisterStub(name, ip, port, mDDNSServicePassword);
			DDNSResultObject response = _serverIterate(callStub);
			if ( !response.mDone ) throw new DDNSRuntimeException("register didn't return done==true, but didn't throw exception");
		
			// put the node we just registered in our own cache as a sticky node
			DDNSCacheNode node = (DDNSCacheNode)response.mNode; 
			mCache.addStickyNode(node, response.mLifetime);
			
		} catch (JSONException e) {
			String msg = "JSONException registering " + name + ": " + e.getMessage(); 
			Log.e(TAG, msg);
			throw new DDNSRuntimeException(msg);
		}
	}
	
	/**
	 * Resolves a name to an ARecord containing an address.  Throws an exception if no ARecord w/ address can be found.
	 * @param name
	 * @return The ARecord for the name, if one is found
	 * @throws DDNSException
	 */
	public ARecord resolve(String nameStr) throws DDNSException, JSONException {
		// Responsibilties of this routine: Convert from DDNSCacheNode to ARecord
		
		DDNSServiceResolveStub callStub = new DDNSServiceResolveStub(new DDNSFullName(nameStr));
		DDNSResultObject response = _serverIterate(callStub);
		if ( !response.mDone ) throw new DDNSRuntimeException("register didn't return done==true, but didn't throw exception");

		DDNSCacheNode resultNode = (DDNSCacheNode)response.mNode;
		
		// null shouldn't be possible, but some broken server might return void
		if ( resultNode == null || resultNode.record() == null ) {
			Log.e(TAG, "resolve(" + callStub.name() + ") got null record");
			throw new DDNSRuntimeException("Got null response resolving name '" + callStub.name() + "'");
		}
		if ( resultNode.isNegative() ) throw new DDNSNoAddressException(callStub.name());
		
		ARecord aRecord = null;
		try {
			// if the record isn't an address record, the cast will cause an exception
			aRecord = (ARecord)resultNode.record(); 
		} catch (Exception e ) {
			Log.e(TAG,"Got odd record from _resolveToNode(" + callStub.name() + "): " + resultNode.record().toString());
			throw new DDNSNoAddressException(callStub.name());
		}
		return aRecord;
	}
	
	/**
	 * Performs the iterative resolution/registration of names, cycling over name servers as needed.
	 * @param callStub
	 * @return
	 * @throws DDNSException
	 * @throws JSONException
	 */
	private DDNSResultObject _serverIterate(DDNSServiceRPCStub callStub) throws DDNSException, JSONException {
		
		// set up in case we need to query a server
		DDNSCacheNode ddnsServerNode = mRootServerNode;
		
		// if we happen to be executing for a register() request, we may see an ns record followed by an soa.
		// If that case, we need to return the minimum lifetime of the two, so that a keep alive registration
		// takes place in time for both.
		int previousLifetime = Integer.MAX_VALUE;
		
		DDNSCacheNode node = null;
		int serversRemaining = mMaxServerTTL;
		while ( serversRemaining-- > 0) {
			
			node = callStub.useCachedNode() ? mCache.readNode(callStub.name()) : null;
			if ( node != null ) {
				if ( node.isNegative()) throw new DDNSNoAddressException(callStub.name());
				if ( node.noSuchName() ) throw new DDNSNoSuchNameException(callStub.name());
				// Note: HAVE TO return an NS record, because the only other way out of this loop
				// is inside the else clause of this then block...
				if ( node.record().type() == RRType.RRTYPE_A || node.record().type() == RRType.RRTYPE_SOA ) {
					DDNSResultObject response = new DDNSResultObject();
					response.mNode = node;
					response.mDone = true;
					return response;
				}
				// if it's an NS record, we have a problem: the NS record will cause a change to the ddnsServerNode value,
				// but when we try to look for the SOA record we'll instead get a hit on the cached NS record again, leading
				// to a loop and TTL expiry.
				// So, we ignore NS record hits.
				if ( node.record().type() == RRType.RRTYPE_NS ) node = null;
			}

			if ( node == null ) {
				try {
					DDNSResultObject response = callStub.call(ddnsServerNode); //_ddnsInvoke(resolveTTL, name, "resolve", args, ddnsServerNode);

					// if a node was returned, cache it
					node = (DDNSCacheNode)response.mNode;
					if ( node != null ) {
						mCache.addNode(node);  // it's up to register() to do a sticky insert, but this one won't hurt
						// If we're returning an soa, we just saw an ns.  We want the lifetime to be the minimum of those two.
						// In general, take the minimum lifetime of any server storing the name we're looking for
						if ( node.name().toString().equals(callStub.name().toString()) ) {
							response.mLifetime = previousLifetime < response.mLifetime ? previousLifetime : response.mLifetime; 
							previousLifetime = response.mLifetime;
						}
					}
					if ( response.mDone ) return response;
					
				} catch (DDNSNoSuchNameException nsne) {
					mCache.addNode( new DDNSCacheNode(callStub.name(), new ARecord()).setNoSuchName(true) );
					throw nsne;
				} catch (DDNSNoAddressException nae) {
					DDNSCacheNode newNode = new DDNSCacheNode(callStub.name(), new ARecord());
					newNode.setIsNegative(true);
					mCache.addNode( newNode );
					throw nae;
				}
			}

			RRType nodeType = node.record().type();
			if ( nodeType == RRType.RRTYPE_NS ) ddnsServerNode = node;   // need to follow the link
			else if ( nodeType == RRType.RRTYPE_CNAME ) {
				DDNSFullName name = callStub.name();
				Log.i(TAG, "CNAME pre: " + name);
				DDNSFullName alias = ((CNAMERecord)node.record()).alias(); 
				if ( name.toString().length() == node.name().toString().length() ) name = alias;
				else name = new DDNSFullName( name.toString().substring(0, name.toString().length() - node.name().toString().length()) + alias );
				callStub.setName(name);
				ddnsServerNode = mRootServerNode;
				Log.i(TAG, "CNAME post: " + name);
			}
			// nodeType == RRType.RRTYPE_A || nodeType == RRType.RRTYPE_SOA
			else throw new DDNSRuntimeException("A or SOA node returned by DDNS service but done set to false");
		}
		throw new DDNSTTLExpiredException(callStub.name());
	}

	public String toString(String prefix) {
		StringBuilder sb = new StringBuilder();
		return _toString(sb, prefix).toString();
	}
	
	public StringBuilder _toString(StringBuilder sb, String prefix) {
		return mCache._toString(sb, prefix);
	}
}
