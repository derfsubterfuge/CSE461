package edu.uw.cs.cse461.sp12.OS;

import java.util.Timer;
import java.util.Vector;

import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.CommandLineParser;
import org.apache.commons.cli.HelpFormatter;
import org.apache.commons.cli.Options;
import org.apache.commons.cli.PosixParser;
import org.json.JSONException;
import org.json.JSONObject;

import edu.uw.cs.cse461.sp12.OS.DDNSException.DDNSAuthorizationException;
import edu.uw.cs.cse461.sp12.OS.DDNSException.DDNSNoSuchNameException;
import edu.uw.cs.cse461.sp12.OS.DDNSException.DDNSRuntimeException;
import edu.uw.cs.cse461.sp12.OS.DDNSException.DDNSTTLExpiredException;
import edu.uw.cs.cse461.sp12.OS.DDNSException.DDNSZoneException;
import edu.uw.cs.cse461.sp12.OS.DDNSNode.DDNSTreeNode;
import edu.uw.cs.cse461.sp12.OS.DDNSRRecord.ARecord;
import edu.uw.cs.cse461.sp12.OS.DDNSRRecord.CNAMERecord;
import edu.uw.cs.cse461.sp12.OS.DDNSRRecord.NSRecord;
import edu.uw.cs.cse461.sp12.OS.DDNSRRecord.RRType;
import edu.uw.cs.cse461.sp12.OS.DDNSRRecord.SOARecord;
import edu.uw.cs.cse461.sp12.OS.DDNSServiceRPCStub.DDNSServiceRegisterStub;
import edu.uw.cs.cse461.sp12.OS.DDNSServiceRPCStub.DDNSServiceResolveStub;
import edu.uw.cs.cse461.sp12.OS.DDNSServiceRPCStub.DDNSServiceUnregisterStub;
import edu.uw.cs.cse461.sp12.OS.HTTPDService.HTTPProvider;
import edu.uw.cs.cse461.sp12.OS.OSLoadable.OSLoadableService;
import edu.uw.cs.cse461.sp12.util.Log;

/**
 * Protocol: Based on RPC.  The calls:
 * <p>
 * Request:  method: "register" 
 *           args: 
 * <br>Response:  void
 * <p>
 * Fetch all records (for all apps) for a specific host.
 * Request:  method: "fetchall"
 *           args:  {host: hostname}
 * <br>Response:  [ [appname, port, authoritative], ...]
 *
 * <pre>
 * app:"ddns" supports RPC calls:
 *     register( {host: hostname,  ip: ipaddr,   port: portnum} ) => { status: "OK" } or errormsg
 *     resolve( { host: hostname } ) => { host: repeats hostname, ip: ip address, authoritative: boolean } ) or errormsg
 * </pre>
 * 
 *  * @author zahorjan
 *
 */
public class DDNSService implements OSLoadableService, HTTPProvider {
	private static String TAG="DDNSService";
	
	// how long a registered address should survive before being set to no address
	private static final int DEFAULTCLEANINTERVAL = 300;
	private static final int MINIMUMCLEANINTERVAL = 10;
	private int mCleanInterval;
	private Timer mTimer;

	private DDNSTreeNode mRoot;  // root of name tree
	private DDNSFullName mMyZone; // root name of my zone
	private String mMyPassword;
	
	// how many steps to take searching for a name in this zone
	private static final int DEFAULTRESOLUTIONSTEPS = 50;
	private static final int MAXRESOLUTIONSTEPS = 300;
	private int mMaxResolutionSteps;
	
	private RPCCallableMethod<DDNSService> resolve;
	private RPCCallableMethod<DDNSService> register;
	private RPCCallableMethod<DDNSService> unregister;

	@Override
	public String loadablename() { return "ddns"; }
	
	/**
	 * Called to end execution.  Specifically, need to terminate any threads we've created.
	 */
	@Override
	public void shutdown() {
		if ( mTimer != null ) mTimer.cancel();
		mTimer = null;
	}
	
	@Override
	public String httpServe(String[] uriArray) { return toString();	}
	
	public static class ResultObject {
		DDNSTreeNode mNode;
		int mTTL;
		boolean mDone;
		int mCleanInterval;
		ResultObject(int ttl, int cleanInterval) {
			mNode = null;
			mTTL = ttl;
			mDone = false;
			mCleanInterval = cleanInterval;
		}
	}
	
	/**
	 * Constructor.  Registers the system RPCServerSocket with the parent as
	 * this host's ip address.  Registers the root server and itself in the
	 * local name cache.
	 * @throws DDNSException
	 */
	DDNSService() throws DDNSException {
		
		try {
			mRoot = null;
			
			//--------------------------------------------------------------
			// get this host's address
			//--------------------------------------------------------------

			RPCService rpcService = (RPCService)OS.getService("rpc");
			String myIP = rpcService.localIP();
			int myPort = rpcService.localPort();
			Log.d(TAG, "myAddress = " + myIP + ":" + myPort);
			
			//--------------------------------------------------------------
			// Find max steps to take during resolve
			//--------------------------------------------------------------
			
			mMaxResolutionSteps = OS.config().getInt("ddns.resolvettl", DEFAULTRESOLUTIONSTEPS, 10, MAXRESOLUTIONSTEPS, TAG); 

			//--------------------------------------------------------------
			// add names configured in the config file
			//   Entries in config file are <recordtype>:<nameservername>:<password to update this record>
			//--------------------------------------------------------------
			
			Vector<String[]> recordVec = OS.config().readNameRecordVec("ddns.nodes");

			ResultObject resultObj;
			for (String[] entry : recordVec ) {
				DDNSRRecord record = null;
				String type = entry[0].toLowerCase();
				DDNSFullName name = new DDNSFullName(entry[1]);
				String password = entry[entry.length-1];

				// the soa record must be the first one into the tree
				if ( mRoot==null && !type.equals("soa") ) throw new DDNSRuntimeException("First node in ddsn.nodes in config file must be SOA");
				
				if ( type.equals("a") ) record = new ARecord();
				else if ( type.equals("ns") ) record = new NSRecord();
				else if ( type.equals("soa")) {
					record = new SOARecord(myIP, myPort);
					mMyZone = name;
					mMyPassword = password;
				}
				else if ( type.equals("cname")) {
					record = new CNAMERecord(entry[2]);
				}
				else throw new DDNSRuntimeException("Unrecognized record type (" + type + ") in ddns.nodes in config file");
				
				// don't have to execute synchronized here because we're in the constructor
				_addName( new DDNSTreeNode( name, password, record), mMyPassword );
			}
			
			//--------------------------------------------------------------
			// establish clean interval
			//--------------------------------------------------------------
			
			mTimer = new Timer();
			mCleanInterval = OS.config().getInt("ddns.cleaninterval", DEFAULTCLEANINTERVAL, MINIMUMCLEANINTERVAL, TAG);
			
			//--------------------------------------------------------------
			// set up RPC callable methods
			//--------------------------------------------------------------

			// export methods via the rpc service
			resolve = new RPCCallableMethod<DDNSService>(this, "_rpcResolve");
			register = new RPCCallableMethod<DDNSService>(this, "_rpcRegister");
			unregister = new RPCCallableMethod<DDNSService>(this, "_rpcUnregister");

			rpcService.registerHandler(loadablename(), "register", register );
			rpcService.registerHandler(loadablename(), "unregister", unregister );
			rpcService.registerHandler(loadablename(), "resolve", resolve );
			
			Log.d(TAG, "Starting ddns service for zone '" + this.mMyZone + "' on host '" + OS.hostname() + "' on port " + myPort);
			Log.d(TAG, toString());
			
		} catch (Exception e) {
			String msg = "DDNSService constructor caught exception: " + e.getMessage();
			Log.e(TAG, msg);
			throw new DDNSRuntimeException(msg);
		}
	}
	
	private DDNSFullName zone() { 
		return this.mMyZone;
	}
	
	//---------------------------------------------------------------------------------------------------------------------------
	// name tree manipulation
	
	/**
	 * This routine injects new names into the tree.  It turns out to be handy to allow injection of names
	 * that are not immediate children of any existing node.  When that happens, we create the missing nodes,
	 * setting them up as negative A records.
	 *
	 * @param result  Structure for passing in resolve TTL, and returning node found and remaining TTL  
	 * @param node
	 * @param password
	 * @throws DDNSRuntimeException
	 * @throws DDNSTTLExpiredException
	 * @throws DDNSZoneException
	 * @throws DDNSAuthorizationException
	 */
	private DDNSTreeNode _addName(DDNSTreeNode node, String password)
			throws DDNSRuntimeException, DDNSTTLExpiredException, DDNSZoneException, DDNSAuthorizationException {

		//NOTE: If root is null, we never check authorization!
		if ( mRoot == null ) {
			mRoot = node;
			return node;
		}
		
		ResultObject resultObj = new ResultObject(mMaxResolutionSteps, mCleanInterval);
		_findLast(resultObj, node.name());
		DDNSTreeNode lastNode = resultObj.mNode; 
		
		// node exists
		if ( lastNode.name().equals(node.name()) ) throw new DDNSRuntimeException("addNode: Node " + node.name() + " already exists");
		// found a node leading us out of our zone
		if ( lastNode.record().type() == RRType.RRTYPE_NS ) throw new DDNSZoneException(node.name(), zone());
		// can't add nodes below a CNAME
		if ( lastNode.record().type() == RRType.RRTYPE_CNAME ) throw new DDNSRuntimeException("Can't create nodes below CNAMEs");
		
		// need to create intermediary node(s)?
		while (	resultObj.mTTL > 0 && !node.name().parent().equals(resultObj.mNode.name()) ) {
			DDNSTreeNode newNode = new DDNSTreeNode( lastNode.name().nextAncestor(node.name()), password, new ARecord(null, -1));
			resultObj.mNode.addChild(newNode, password);
			resultObj.mNode = newNode;
			resultObj.mTTL--;
		}

		// found immediate parent
		resultObj.mNode.addChild(node, password);   // auth check happens here
		return node;
	}
	
	/**
	 * Resolve name as far as possible, and return node you end up on.
	 * 
	 * @param result  Return structure; contains node and remaining TTL count. The node is 
	 * the last node visited in the search.  Could be the node with the given name.  Could be a leaf ancestor of that node.
	 * Could be that the TTL expried and it's an arbitrary node.
	 * @param fullname
	 * @throws DDNSTTLExpiredException
	 * @throws DDNSRuntimeException
	 */
	private void _findLast(ResultObject resultObj, DDNSFullName fullname) throws DDNSTTLExpiredException, DDNSRuntimeException {
		String name = fullname.toString();
		String suffix = mRoot.name().toString();
		if ( !name.endsWith(suffix) ) throw new DDNSRuntimeException("Node " + name + " isn't in this zone [" + suffix + "]");
		
		name = name.substring(0, name.length() - suffix.length() );
		String[] token = name.split("\\.");
		
		//TODO: Handle CNAMEs...
		
		resultObj.mNode = mRoot;
		if ( resultObj.mNode == null ) throw new DDNSRuntimeException("_findLast called when the tree is empty");
		DDNSTreeNode nextNode;
		for ( int index = token.length-1; index >= 0; index-- ) {
			if (resultObj.mNode.record().type() == RRType.RRTYPE_CNAME ) return;
			nextNode = resultObj.mNode.child(new DDNSFullName(token[index] + "." + resultObj.mNode.name()));
			if ( nextNode == null ) break;
			if ( --resultObj.mTTL <= 0 ) throw new DDNSTTLExpiredException(fullname);
			resultObj.mNode = nextNode;
		}
	}
	
	//---------------------------------------------------------------------------
	// RPC callable routines
	
	/**
	 * Indicates host is going offline.
	 *      unregister( {name: name, password: password} ) => { status: "OK" } or errormsg
	 * @param args
	 * @return
	 * @throws JSONException
	 * @throws DDNSException
	 */
	private JSONObject _rpcUnregister(JSONObject args) {
		// can't just invoke _rpcRegister with ip -> null because of JSONObject except issues regarding null
		try {
			DDNSFullName name = new DDNSFullName(args.getString("name"));
			String password = args.getString("password");
			ResultObject resultObj = register(name, null, -1, password);
			return DDNSServiceUnregisterStub.marshall(resultObj); // void return
		} catch (DDNSException e) {
			return DDNSResultObject.marshall(e);
		} catch (JSONException e) {
			return DDNSResultObject.marshall( new DDNSRuntimeException("unregister caught JSON exception: " + e.getMessage()) );
		}
	}
	
	/**
	*   register( {name: <string>, password: <string>, ip: <string>,  port: <int>} ) => { DDNSNode } or errormsg
	*<p>
	* We accept only requests for names stored on this server.
	* 
	* @param args
	* @return
	*/
	private JSONObject _rpcRegister(JSONObject args) {
		try {
			Log.i(TAG, "_rpcRegister(" + args + ")");

			DDNSFullName name = new DDNSFullName(args.getString("name"));
			String ip = (String)args.get("ip");   // getString throws an exception if the value associated with key "ip" is null
			int port = args.getInt("port");
			String password = args.getString("password");
			ResultObject resultObj = register(name, ip, port, password);
			return DDNSServiceRegisterStub.marshall(resultObj);
		} catch (DDNSException e) {
			return DDNSResultObject.marshall(e);
		} catch (JSONException ee) {
			return DDNSResultObject.marshall( new DDNSRuntimeException("register caught JSON exception: " + ee.getMessage()) );
		}
	}
	
	/**
	 * This version is invoked via RPC.  It's simply a wrapper that extracts the call arguments
	 * and invokes resolve(host).
	 * @param callArgs
	 * @return
	 */
	private JSONObject _rpcResolve(JSONObject args) {
		Log.i(TAG, "_rpcResolve(" + args + ")");
		
		// resolve calls don't require passwords
		try {
			String nameStr = args.getString("name");
			if ( nameStr == null ) throw new JSONException("Malformed call arguments: '" + args.toString() + "'");
			DDNSFullName name = new DDNSFullName(nameStr);
			
			ResultObject resultObj = resolve(name); 
			return DDNSServiceResolveStub.marshall(resultObj);
			
		} catch (DDNSException de) {
			return DDNSResultObject.marshall(de);
		} catch (Exception e) {
			return DDNSResultObject.marshall( new DDNSRuntimeException(e.getMessage()) );
		}
	}
	
	// RPC callable routines
	//---------------------------------------------------------------------------

	/**
	 * Resolves a name to a DDNSNode, recursing into other servers if required.  The name must
	 * be a descendent of this server's zone.
	 * @param name  The name to resolve
	 * @param resolveTTL Resolution step limit
	 * @return 
	 * @throws DDNSRuntimeException
	 */
	private ResultObject resolve(DDNSFullName name) throws DDNSNoSuchNameException, DDNSRuntimeException {
		Log.d(TAG, "Resolve(" + name + ")");

		try {
			ResultObject resultObj = new ResultObject(mMaxResolutionSteps, mCleanInterval);
			_findLast(resultObj, name);

			DDNSRRecord responseRecord = resultObj.mNode.record();
			switch(responseRecord.type()) {
			case RRTYPE_A:
			case RRTYPE_SOA:
								if ( !resultObj.mNode.name().equals(name) ) throw new DDNSNoSuchNameException(name);
								return resultObj;
								
			case RRTYPE_CNAME:
								return resultObj;
								
			case RRTYPE_NS:
								return resultObj;
								
			default:
								throw new DDNSRuntimeException("Encountered node of type " + responseRecord.type() + " resolving name '" + name + "'");
			}
			
		} catch (DDNSNoSuchNameException dnsne) {
			Log.e(TAG, dnsne.getMessage());
			throw dnsne;
		} catch (DDNSRuntimeException dre) {
			Log.e(TAG, dre.getMessage());
			throw dre;
		} catch (Exception e) {
			String msg = "resolve(" + name + "): " + e.getMessage();
			Log.e(TAG, msg);
			throw new DDNSRuntimeException(msg);
		}
	}
	
	/**
	 * Update address mapping for an existing name.
	 * Works only on names stored locally -- no forwarding is done, except for SOA records,
	 * in which case the parent zone is notified.
	 * 
	 * @param name Name to update
	 * @param ip New ip address
	 * @param port New port
	 * @param password Password for the node
	 * @return The updated node
	 * @throws DDNSTTLExpiredException
	 * @throws DDNSNoSuchNameException
	 * @throws DDNSRuntimeException
	 */
	synchronized private ResultObject register(DDNSFullName name, String ip, int port, String password)
			throws DDNSTTLExpiredException, DDNSNoSuchNameException, DDNSRuntimeException, DDNSAuthorizationException, DDNSZoneException {
		Log.d(TAG, "register(" + name + ", " + ip + ", " + port + ")");
		
		ResultObject resultObj = new ResultObject(mMaxResolutionSteps, mCleanInterval);
		_findLast(resultObj, name);

		if ( resultObj.mNode != null ) {
			// existing node
			switch( resultObj.mNode.record().type()) {
			case RRTYPE_NS:		// NS may be what we want to update, or we're just passing through.
								// Eventually, caller must pursue next server (to update SOA or to continue name resolution)
								if ( resultObj.mNode.name().equals(name) ) resultObj.mNode.updateAddress( ip, port, password, mTimer, mCleanInterval);
								break;
			case RRTYPE_SOA:
			case RRTYPE_A:		if ( resultObj.mNode.name().equals(name) ) resultObj.mNode.updateAddress( ip, port, password, mTimer, mCleanInterval);
								else resultObj.mNode = null;  // indicate name not found to code below
								break;

			case RRTYPE_CNAME:	// have to return CNAME to caller to re-eval, as it may be in another zone
								break;
			}
		}
		
		if ( resultObj.mNode == null) {
			// create node, including any required ancestors
			resultObj.mNode = new DDNSTreeNode(name, password, new ARecord(ip, port) );
			_addName(resultObj.mNode, password).updateAddress( ip, port, password, mTimer, mCleanInterval );
		}
		
		return resultObj;
	}
	
	/**
	 * The usual toString.
	 */
	public String toString() {
		StringBuilder sb = new StringBuilder();
		String zone = OS.hostname();
		sb.append("Zone: ");
		if ( zone != null ) sb.append(zone).append("\n");
		else sb.append("undefined\n");
		
		mRoot._toString(sb,  "");
		return sb.toString();
	}

	/**
	 * A simple test driver that ends up dumping the current cached naming information.
	 * @param args
	 */
	public static void main(String[] args) {
		final String TAG="DDNSAgent.main";
		String configFilename = "config.ini";
		try {
			// This code deals with command line options
			Options options = new Options();
			options.addOption("f", "configfile", true, "Config file name (Default: " + configFilename + ")");
			options.addOption("h", "help", false, "Print this message");

			CommandLineParser parser = new PosixParser();

			CommandLine line = parser.parse(options, args);
			if ( line.hasOption("help") ) {
				HelpFormatter formatter = new HelpFormatter();
				formatter.printHelp(DDNSService.class.getName(), options );
				return;
			}
			if ( line.hasOption("configfile") ) configFilename = line.getOptionValue("configfile");

			OS.boot(configFilename);

			DDNSResolverService resolver = (DDNSResolverService)OS.getService("ddnsresolver");
			Log.e(TAG, resolver.toString());

			// Resolve a host
			DDNSRRecord testAddress = resolver.resolve(OS.hostname());
			Log.e(TAG, testAddress.toString());

			testAddress = resolver.resolve(OS.hostname());
			Log.e(TAG, testAddress.toString());
			
			testAddress = resolver.resolve("");
			Log.e(TAG, testAddress.toString());

			testAddress = resolver.resolve(new DDNSFullName(OS.hostname()).parent().toString());
			Log.e(TAG, testAddress.toString());

			testAddress = resolver.resolve("foo.jz.cse461");
			Log.e(TAG, testAddress.toString());

			testAddress = resolver.resolve("foo.cse461");
			Log.e(TAG, testAddress.toString());

		} catch (Exception e) {
			Log.e(TAG, "DDNSAgent caught exception: " + e.getMessage());
		}
	}
}
