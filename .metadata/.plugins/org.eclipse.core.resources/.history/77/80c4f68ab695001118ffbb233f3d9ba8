package edu.uw.cs.cse461.sp12.OS;

import java.util.Iterator;

import org.json.JSONException;
import org.json.JSONObject;

import edu.uw.cs.cse461.sp12.OS.DDNSException.DDNSRuntimeException;
import edu.uw.cs.cse461.sp12.OS.DDNSNode.DDNSCacheNode;
import edu.uw.cs.cse461.sp12.OS.DDNSNode.DDNSTreeNode;
import edu.uw.cs.cse461.sp12.util.Log;

/**
 * All DDNSService RPC class return almost the same thing.  This class represents
 * the union of those things.
 * <p>
 * There are two sides to this.  The DDNSService uses one of these one of these to
 * accumulate its response.  It then calls the appropriate marshall() routine in
 * DDNSServiceRPCStub to convert it to a JSONObject for transmission over the wire.
 * <p>
 * The caller side invokes the method-specific call() method, which makes the RPC,
 * gets back the JSON object, and ands that to the constructor here to create
 * one of these to give the actual client caller.
 * <p>
 * (So, both marshall and unmarshall happen in the DDNSServiceRPCStub code.)
 *  
 * @author zahorjan
 *
 */
class DDNSResultObject {
	private final static String TAG="DDNSResponse";
	
	DDNSNode mNode;  // holds a TreeNode in DDNSService code, a CacheNode in DDNSResolver code
	boolean mDone;   // true if operation reached the named node; false if it didn't
	int mLifetime;
	
	//------------------------------------------------------------------------------------
	//------------------------------------------------------------------------------------
	// Callee (DDNSService) side methods
	
	/**
	 * Constructor for callee (DDNSService) side.
	 * 
	 * @param ttl
	 * @param cleanInterval
	 */
	DDNSResultObject(int cleanInterval) {
		mNode = null;
		mDone = false;
		mLifetime = cleanInterval;
	}
	
	
	/**
	 * Returning a DDNSException
	 * @param e
	 * @return
	 */
	static JSONObject marshall(DDNSException e) {
		try {
			JSONObject result = e.marshall();
			result.put("resulttype", "ddnsexception");
			return result;
		} catch (JSONException ee) {
			Log.e(TAG, "Fatal error trying to create JSONObject from exception: " + ee.getMessage() +
					   "Original exception message: " + e.getMessage()
				 );
			return new JSONObject(); // can't do much else -- adding anything can throw a JSONException
		}
	}
	
	// normal result marshall routines are in DDNSServiceRPCSTub
	
	// Callee (DDNSService) side methods
	//------------------------------------------------------------------------------------
	//------------------------------------------------------------------------------------
	

	
	//------------------------------------------------------------------------------------
	//------------------------------------------------------------------------------------
	// Caller (DDNSResolver) side methods
	
	/**
	 * "Constructor" for caller (DDNSResolverService) side.  It gets a JSONObject off the wire
	 * and hands it to this routine.
	 * @param obj
	 * @throws DDNSException
	 * @throws JSONException
	 */
	static DDNSResultObject unmarshall(JSONObject obj) throws JSONException, DDNSException {
		try {
			String type = obj.getString("resulttype");
			
			// an exception was returned
			if ( type.equals("ddnsexception") ) {
				// this call will throw the exception
				DDNSException.unmarshall(obj);
				// never reached, but needed to compile
				return null;
			}
			
			if ( type.equals("resolveresult"))    return DDNSServiceResolveStub.unmarshall(obj);
			if ( type.equals("registerresult"))   return DDNSServiceRegisterStub.unmarshall(obj);
			if ( type.equals("unregisterresult")) return DDNSServiceUnregisterStub.unmarshall(obj);
			
			
			// not an exception.  All RCP calls return almost the same thing (so we ignore the resulttype...
			DDNSResultObject result = new DDNSResultObject(0);
			Iterator<String> it = obj.keys();
			while ( it.hasNext() ) {
				String key = it.next();
				if ( key.equals("node") ) 			put("node", new DDNSCacheNode(obj.getJSONObject("node")));
				else if ( key.equals("done"))		result.mDone = obj.getBoolean("done");
				else if ( key.equals("lifetime")) 	result.mLifetime = obj.getInt("lifetime");
			}
		} catch (JSONException e) {
			throw new DDNSRuntimeException("Response not parsable as DDNS response: " + obj.toString());
		}
	}
	
	// Caller (DDNSResolver) side methods
	//------------------------------------------------------------------------------------
	//------------------------------------------------------------------------------------
	
	
	
	/**
	 * Give JSONObject returned by some server on a ddns call, converts it to a DDNSNode, 
	 * throws a DDNSException, or converts it to null.
	 * @param obj
	 * @return
	 * @throws DDNSException
	 */
	static JSONObject unmarshall(JSONObject obj) throws DDNSException {
		try {
			String type = obj.getString("resulttype");
			
			// an exception was returned
			if ( type.equals("ddnsexception") ) {
				// this call will throw the exception
				DDNSException.unmarshall(obj);
				// never reached, but needed to compile
				return null;
			}
			return obj;
		} catch (JSONException e) {
			throw new DDNSRuntimeException("Response not parsable as DDNS response: " + obj.toString());
		}
	}

}
