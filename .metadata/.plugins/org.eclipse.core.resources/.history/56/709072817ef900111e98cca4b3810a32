package edu.uw.cs.cse461.Net.Base;

import java.util.HashMap;
import java.util.Set;

import edu.uw.cs.cse461.Net.Base.IPFinder;
import edu.uw.cs.cse461.Net.Base.NetLoadableInterface.NetLoadableApp;
import edu.uw.cs.cse461.Net.Base.NetLoadableInterface.NetLoadableService;
import edu.uw.cs.cse461.util.ConfigManager;
import edu.uw.cs.cse461.util.Log;

/**
 * A singleton class (only one instance can exist) implementing core network stack functionality.
 * It is initialized by calling init() and then startServices().
 * It's shut down by calling shutdown(). Its major responsibility is to bring up
 * services, like rpc, and make them available to apps (via getService()).
 * 
 * @author zahorjan
 * 
 */
public class NetBase implements NetBaseInterface {
	private static final String TAG = "NetBase";

	private static NetBase theNetBaseInstance = new NetBase();  // the singleton NetBase instance
	
	private boolean mAmShutdown = true;
	private ConfigManager mConfig;
	private String mHostname;

	/**
	 * Used to keep track of started services. The String key is the name
	 * returned by the // service's servicename() method.
	 */
	private static HashMap<String, NetLoadableService> serviceMap = new HashMap<String, NetLoadableService>();

	/**
	 * Used to keep start of loaded apps.
	 */
	private static HashMap<String, NetLoadableApp> mAppMap = new HashMap<String, NetLoadableApp>();

	/**
	 * Only this class can construct an instance of itself, and it does that only once, to initialize static variable theNetBaseInstance.
	 */
	private NetBase() {
	}
	
	/**
	 * Returns the singleton NetBase instance
	 * @return
	 */
	public static NetBase theNetBase() {
		return theNetBaseInstance;
	}

	/**
	 * Brings up the NetBase, then loads services, then starts the shell program.
	 * 
	 * @param configMgr Configuration settings read by caller from a config file.
	 * @param isConsoleMode True if we're running in console mode, false if in Android
	 * @throws Exception
	 */
	public synchronized void init(ConfigManager configMgr, boolean isConsoleMode)
			throws Exception {
		Log.d(TAG, "NetBase initializing");
		
		// sanity check
		if (!mAmShutdown)
			throw new RuntimeException(
					"Call to NetBase.init() but NetBase is already initialized!");
		
		mConfig = configMgr;

		if (configMgr == null) Log.e(TAG, "configMgr is null in call to NetBase::init()");

		int showDebug = mConfig.getAsInt("debug.enable", 1, TAG);
		Log.setShowLog(showDebug != 0);
		int debugLevel = mConfig.getAsInt("debug.level", Log.DebugLevel.DEBUG.toInt(), TAG);
		Log.setLevel(debugLevel);

		// code uses the host name a lot, so cache it in it's typical form (no
		// trailing '.')
		mHostname = mConfig.getProperty("net.hostname");
		if (mHostname == null) {
			Log.w(TAG, "NetBase: no net.hostname entry in config file");
			mHostname = "";
		} else {
			// convert full name to more colloquial name (no trailing period) 
			if (mHostname.equals(".")) mHostname = "";
			else if (mHostname.endsWith("."))
				mHostname = mHostname.substring(0, mHostname.length() - 1);
		}
		Log.d(TAG, "Booting host '" + mHostname + "'");

		mAmShutdown = false; // at this point, we're up, but with no services
								// running

		_startServices();
		_loadApps();

		// if there is an initialapp app, start it. Otherwise, just run as a
		// daemon
		String initialAppName = config().getProperty("console.initialapp");
		if (initialAppName != null) {
			try {
				startApp(initialAppName);
			} catch (Exception e) {
				Log.e(TAG,	initialAppName + " threw exception: " + e.getMessage());
			}
			shutdown(); // we're done when the inital app terminates
		}
	}
	
	/**
	 * Starts the "network services" listed in the config file.
	 * The argument is an array of class names.
	 */
	private void _startServices() {
		String[] serviceClassList = config().getAsStringVec("net.services");
		if (serviceClassList == null) {
			Log.e(TAG, "Missing or empty net.services in config file.  The system won't run this way.");
			return;
		}

		String startingService = null; // for debugging output in catch block
		for (String serviceClassname : serviceClassList) {
			try {
				Log.d(TAG, "Starting service " + serviceClassname);
				startingService = serviceClassname;
				// Get the Java Class object
				Class<NetLoadableService> serviceClass = (Class<NetLoadableService>) Class
						.forName(serviceClassname);
				// Create an instance of the class
				NetLoadableService service = serviceClass.newInstance();
				// Record the instance in a Map, keyed by the service's
				// self-proclaimed name
				serviceMap.put(service.loadablename(), service);
				Log.i(TAG, serviceClassname + " started");
			} catch (Exception e) {
				Log.e(TAG, "Error while starting service " + startingService
						+ ": " + e.getMessage());
			}
		}
	}

	public Set<String> loadedServiceNames() {
		return serviceMap.keySet();
	}

	private void _loadApps() {
		String startingApp = null; // for debugging output in catch block

		String[] appClassList = config().getAsStringVec("console.apps");
		if ( appClassList == null ) return;
		
		for (String appClassname : appClassList) {
			try {
				Log.d(TAG, "Starting app " + appClassname);
				startingApp = appClassname;
				Class<NetLoadableApp> appClass = (Class<NetLoadableApp>) Class.forName(appClassname);
				NetLoadableApp app = appClass.newInstance();
				mAppMap.put(app.loadablename(), app);
				Log.i(TAG, appClassname + " Loaded");
			} catch (ClassNotFoundException nfe) {
				Log.e(TAG, "ClassNotFoundException for " + startingApp);
			} catch (Exception e) {
				Log.e(TAG,
						"Exception loading app " + startingApp + ": "
								+ e.getMessage());
			}
		}
	}

	public Set<String> loadedAppNames() {
		return mAppMap.keySet();
	}

	/**
	 * Runs an app.
	 * 
	 * @param appname
	 *            The name returned by the app's appname() method
	 */
	public void startApp(String appname) throws Exception {
		NetLoadableApp app = mAppMap.get(appname);
		if (app == null)
			throw new RuntimeException("App doesn't exist: '" + appname + "'");
		app.run();
	}
	
	/**
	 * Returns true if NetBase.theNetBase() is ready for use; false otherwise.
	 */
	public boolean isUp() {
		return !mAmShutdown;
	}

	/**
	 * Shutdown associated services and the network. The main point is to terminate
	 * threads, so that app can terminate. If you don't shut down various
	 * services, the odds are the app won't terminate even if the main thread
	 * exits.
	 */
	public synchronized void shutdown() {
		if (mAmShutdown)
			return;
		Log.d(TAG, "NetBase shutting down...");
		try {
			for (String serviceName : serviceMap.keySet()) {
				NetLoadableInterface service = serviceMap.get(serviceName);
				service.shutdown();
			}
			// We can't remove items from the HashMap while iterating
			serviceMap.clear();
		} catch (Exception e) {
			Log.e(TAG, "Error shutting down services: " + e.getMessage());
			throw new RuntimeException(e.getMessage());
		}
		mAmShutdown = true;
	}

	/**
	 * Helper function that simply makes sure the NetBase is running when calls to it
	 * are made.
	 * 
	 * @param method
	 */
	private void check(String method) {
		if (mAmShutdown)
			throw new RuntimeException("NetBase." + method
					+ " called when NetBase isn't in initialized state");
	}

	/**
	 * Get access to the configuration properties read from the config file
	 * specified at launch.
	 * 
	 * @return
	 */
	public ConfigManager config() {
		check("getConfig");
		return mConfig;
	}

	/**
	 * Returns this host's name, if it has one, otherwise null. (This isn't
	 * useful until Project 4.)
	 * 
	 * @return
	 */
	public String hostname() {
		check("hostname");
		return mHostname;
	}

	/**
	 * Takes the value returned by the loadablename() method of the service
	 * you're looking for, and returns that service. (E.g., call with arg "rpc"
	 * to get the RPC service.)
	 * 
	 * @param servicename
	 * @return
	 */
	public NetLoadableService getService(String servicename) {
		check("getService(" + servicename + ")");
		return serviceMap.get(servicename);
	}

	public NetLoadableApp getApp(String appname) {
		check("getApp(" + appname + ")");
		return mAppMap.get(appname);
	}
	
	/**
	 * Returns the IPv4 address of the host.  Tries to find one that is globally routable, but may not always succeed.
	 */
	public String myIP() {
		return IPFinder.getMyIP();
	}

	/**
	 * Returns current Unix time (seconds since 1/1/1970).
	 * 
	 * @return
	 */
	public long now() {
		return System.currentTimeMillis() / 1000L;
	}

}
