package edu.uw.cs.cse461.sp12.OS;

import java.io.IOException;

import org.json.JSONException;
import org.json.JSONObject;

import edu.uw.cs.cse461.sp12.OS.DDNSException.DDNSNoAddressException;
import edu.uw.cs.cse461.sp12.OS.DDNSException.DDNSRuntimeException;
import edu.uw.cs.cse461.sp12.OS.DDNSNode.DDNSCacheNode;
import edu.uw.cs.cse461.sp12.OS.DDNSRRecord.ARecord;
import edu.uw.cs.cse461.sp12.OS.DDNSRRecord.RRType;
import edu.uw.cs.cse461.sp12.OS.DDNSService.ResultObject;

public class DDNSServiceRPCStub {
	private final String TAG="DDNSServiceRPCStub";
	
	protected String mRequestMethod;
	protected JSONObject mRequestArgs;
	
	/**
	 * All calls take a DDNSFullName argument, so it's in the base class.
	 * @param name
	 */
	protected DDNSServiceRPCStub(String mMethod, DDNSFullName name) throws JSONException {
		mRequestArgs = new JSONObject().put("name", name.toString());
	}
	
	DDNSFullName name() throws JSONException {
		return new DDNSFullName(mRequestArgs.getString("name"));
	}
	DDNSServiceRPCStub setName(DDNSFullName name) throws JSONException {
		mRequestArgs.put("name", name.toString());
		return this;
	}
	
	protected DDNSResultObject call(DDNSCacheNode ddnsServerNode) throws DDNSException, JSONException {
		try {
			if ( ddnsServerNode.isNegative() || ddnsServerNode.noSuchName() ) throw new DDNSNoAddressException(name());
			ARecord serverAddressRecord = (ARecord)ddnsServerNode.record();
			
			RPCCallerSocket socket = new RPCCallerSocket( ddnsServerNode.name().toString(),
		                                                  serverAddressRecord.ip(),
		                                                  serverAddressRecord.port()
						                                );
			JSONObject rawResponse = socket.invoke( "ddns", mRequestMethod, mRequestArgs);
			return DDNSResultObject.unmarshall( rawResponse );

		} catch (JSONException je) {
			throw new DDNSRuntimeException("Likely malformed response message: " + je.getMessage());
		} catch (IOException e) {
			throw new DDNSRuntimeException("Got IOException calling server: " + e.getMessage()); // can contact server - name may or may not exist, but we can't get an address
		}
	}
	
	/**
	 * Takes a DDNSService.ResultObject and creates a JSONObject with return values expected by RPC caller.
	 * @param resultObj
	 * @return
	 */
	protected static JSONObject marshall(DDNSService.ResultObject resultObj) throws DDNSException, JSONException {
		return new JSONObject().put("done", resultObj.mDone);
	}
	
	/**
	 * If some method wants to make use of locally cached nodes, it should override this
	 * implementation to look in the cache and return the node found, if any.
	 * @return
	 */
	DDNSCacheNode useCachedNode() {
		return null;
	}
	
	/**
	 * If a node is returned, either done should be false and the node type CNAME or NS,
	 * or done should be true and the node type A or SOA.
	 * 
	 * @author zahorjan
	 *
	 */
	protected static void checkReturnedNode(DDNSResultObject result) throws DDNSRuntimeException {
		if ( result.mNode == null ) return;
		RRType type = result.mNode.record().type(); 
		
		if ( result.mDone ) {
			if ( type != RRType.RRTYPE_A && type != RRType.RRTYPE_SOA && type != RRType.RRTYPE_NS )
				throw new DDNSRuntimeException("Operation indicated done, but returned node has type " + type);
		}
		else {
			if ( type != RRType.RRTYPE_NS && type != RRType.RRTYPE_CNAME )
				throw new DDNSRuntimeException("Operation indicated done, but returned node has type " + type);
		}
	}
	
	//-------------------------------------------------------------
	//-------------------------------------------------------------
	// DDNSResolveStub
	
	public static class DDNSServiceResolveStub extends DDNSServiceRPCStub {
		DDNSServiceResolveStub(DDNSFullName name) throws JSONException {
			super("resolve", name);
		}
		protected static JSONObject marshall(DDNSService.ResultObject resultObj) throws DDNSException, JSONException {
			JSONObject result = DDNSServiceRPCStub.marshall(resultObj);
			result.put("node", resultObj.mNode.marshall() )
				  .put("resulttype", "resolveresult");
			return result;
		}
		protected static DDNSResultObject unmarshall(JSONObject obj) throws DDNSException {
			DDNSResultObject result = new DDNSResultObject();
			try {
				result.mDone = obj.getBoolean("done");
				result.mNode = new DDNSCacheNode( obj.getJSONObject("node"));
				checkReturnedNode(result);
				return result;
			} catch (JSONException e) {
				throw new DDNSRuntimeException("Malformed resolve rpc response: " + obj.toString());
			}
		}
	}

	//-------------------------------------------------------------
	//-------------------------------------------------------------
	// DDNSRegisterStub
	
	public static class DDNSServiceRegisterStub extends DDNSServiceRPCStub {
		DDNSServiceRegisterStub(DDNSFullName name, String ip, int port, String password) throws JSONException {
			super("register",name);
			mRequestArgs.put("ip", ip)
						.put("port", port)
						.put("password", password);
		}
		protected static JSONObject marshall(DDNSService.ResultObject resultObj) throws DDNSException, JSONException {
			JSONObject result = DDNSServiceRPCStub.marshall(resultObj);
			result.put("node", resultObj.mNode.marshall() )
				  .put("lifetime", resultObj.mLifetime )
				  .put("resulttype", "registerresult");
			return result;
		}
		protected static DDNSResultObject unmarshall(JSONObject obj) throws DDNSException {
			DDNSResultObject result = new DDNSResultObject();
			try {
				result.mDone = obj.getBoolean("done");
				result.mNode = new DDNSCacheNode( obj.getJSONObject("node"));
				result.mLifetime = obj.getInt("lifetime");
				checkReturnedNode(result);
				return result;
			} catch (JSONException e) {
				throw new DDNSRuntimeException("Malformed register rpc response: " + obj.toString());
			}
		}
	}


	//-------------------------------------------------------------
	//-------------------------------------------------------------
	// DDNSUnregisterStub
	
	public static class DDNSServiceUnregisterStub extends DDNSServiceRPCStub {
		DDNSServiceUnregisterStub(DDNSFullName name) throws JSONException {
			super("unregister", name);
		}
		protected static JSONObject marshall(DDNSService.ResultObject resultObj) throws DDNSException, JSONException {
			JSONObject result = DDNSServiceRPCStub.marshall(resultObj);
			if ( !result.getBoolean("done") ) result.put("node", resultObj.mNode.marshall() );
			result.put("resulttype", "unregisterresult");
			return result;
		}
		protected static DDNSResultObject unmarshall(JSONObject obj) throws DDNSException {
			DDNSResultObject result = new DDNSResultObject();
			try {
				result.mDone = obj.getBoolean("done");
				if (!result.mDone ) {
					result.mNode = new DDNSCacheNode( obj.getJSONObject("node"));
					checkReturnedNode(result);
				}
				return result;
			} catch (JSONException e) {
				throw new DDNSRuntimeException("Malformed unregister rpc response: " + obj.toString());
			}
		}
	}

}
