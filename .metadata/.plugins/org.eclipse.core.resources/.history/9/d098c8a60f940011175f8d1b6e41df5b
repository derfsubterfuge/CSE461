package edu.uw.cs.cse461.sp12.OS;

import java.io.IOException;
import java.net.UnknownHostException;
import java.util.HashMap;
import java.util.Timer;
import java.util.TimerTask;

import org.json.JSONException;
import org.json.JSONObject;

import edu.uw.cs.cse461.sp12.OS.DDNSException.DDNSNoAddressException;
import edu.uw.cs.cse461.sp12.OS.DDNSException.DDNSNoSuchNameException;
import edu.uw.cs.cse461.sp12.OS.DDNSException.DDNSRuntimeException;
import edu.uw.cs.cse461.sp12.OS.DDNSException.DDNSTTLExpiredException;
import edu.uw.cs.cse461.sp12.OS.DDNSRRecord.ARecord;
import edu.uw.cs.cse461.sp12.OS.DDNSRRecord.CNAMERecord;
import edu.uw.cs.cse461.sp12.OS.DDNSRRecord.RRType;
import edu.uw.cs.cse461.sp12.OS.DDNSRRecord.SOARecord;
import edu.uw.cs.cse461.sp12.OS.DDNSResponse.TTLCount;
import edu.uw.cs.cse461.sp12.OS.HTTPDService.HTTPProvider;
import edu.uw.cs.cse461.sp12.OS.OSLoadable.OSLoadableService;
import edu.uw.cs.cse461.sp12.util.Log;

public class DDNSResolverService implements OSLoadableService, HTTPProvider {
	private static String TAG="DDNSResolverService";
	
	private static final int DEFAULTCACHETTL = 120;
	private static final int DEFAULTCLEANINTERVAL = 65;
	private static final int MINIMUMCLEANINTERVAL = 10;

	private static final int DEFAULTPARENREFRESHINTERVAL = 600;
	private static final int MINIMUMPARENTREFRESHINTERVAL = 60;
	
	private String mDDNSServicePassword;
	private int mMaxResolutionTTL;
	
	private int mCacheHits = 0;
	private int mCacheMisses = 0;

	private Timer mTimer;  // to periodically register with parent
	private long mCacheTTL;
	
	private HashMap<DDNSFullName, DDNSNode> mCache;
	private DDNSNode mRootServerNode;
	
	private RPCCallableMethod<DDNSResolverService> resolve;
	
	@Override
	public String loadablename() {
		return "ddnsresolver";
	}
	
	/**
	 * Called to end execution.  Specifically, need to terminate any threads we've created.
	 */
	@Override
	public void shutdown() {
		if ( mTimer != null ) mTimer.cancel();
		mTimer = null;
		// if we're not the root, we need to unregister
		if ( !new DDNSFullName(OS.hostname()).equals(DDNSFullName.ROOTNAME)) {
			try {
				unregister(new DDNSFullName(OS.hostname()));
			} catch (Exception e) {
				Log.w(TAG, "ADVISORY: Caught exception while unregistering with parent:\n" + e.getMessage());
			}
		}
	}
		
	@Override
	public String httpServe(String[] uriArray) {
		return toString("");
	}
	
	//-----------------------------------------------------------------------------
	//-----------------------------------------------------------------------------
	// Utility classes 
	
	public class CacheCleaner extends TimerTask {
		DDNSFullName key;
		CacheCleaner(DDNSFullName name) { key = name; }
		public void run() { deleteNameFromCache(key); }
	}
	
	// Utility classes 
	//-----------------------------------------------------------------------------
	//-----------------------------------------------------------------------------
	
	public DDNSResolverService() throws DDNSException {
		mCache = new HashMap<DDNSFullName, DDNSNode>();
		mTimer = new Timer();
		
		//--------------------------------------------------------------
		// See if I have a password
		//--------------------------------------------------------------

		mDDNSServicePassword = OS.config().getProperty("ddnsresolver.password");
		if ( mDDNSServicePassword == null ) mDDNSServicePassword = "";  // try using no password
		
		//--------------------------------------------------------------
		// establish resolution TTL
		//--------------------------------------------------------------
		
		mMaxResolutionTTL = OS.config().getInt("ddnsresolver.maxresolutiondepth", 20, 1, 100, TAG);
		
		//--------------------------------------------------------------
		// remember the root host as an uncached cached node
		//--------------------------------------------------------------

		mRootServerNode= new DDNSNode(DDNSFullName.ROOTNAME, new SOARecord(null, -1)).setIsNegative(true);
		String rootHost = OS.config().getProperty("ddns.rootserver");
		if ( rootHost == null ) Log.e(TAG, "DDNSAgent.DDNSAgent: no rootserver in config file");
		else {
			try {
				int rootPort = OS.config().getInt("ddns.rootport");
				mRootServerNode = new DDNSNode(DDNSFullName.ROOTNAME, new SOARecord(rootHost, rootPort) );
			} catch (NoSuchFieldException e) {
				Log.e(TAG, "No ddns.rootport entry in config file");
			}
		}

		//--------------------------------------------------------------
		// fetch cachettl info
		//		ddnsresolver.cachettl == 0 means don't cache.
		//--------------------------------------------------------------

		mCacheTTL = OS.config().getInt("ddnsresolver.cachettl", DEFAULTCACHETTL, 0, TAG);
		Log.d(TAG, "Cache ttl = " + mCacheTTL + " seconds");
		
		//--------------------------------------------------------------
		// Register with parent, unless we're the root
		//--------------------------------------------------------------
		
		if ( !new DDNSFullName(OS.hostname()).equals(DDNSFullName.ROOTNAME)) {
			// perform first update synchronously, to ensure it's done before any other service needs it
			_doRegisterWithParent();

			int refreshInterval = OS.config().getInt("ddns.parentrefreshinterval", DEFAULTPARENREFRESHINTERVAL, MINIMUMPARENTREFRESHINTERVAL, TAG);
			Log.i(TAG, "Refresh interval = " + refreshInterval + " seconds");

			mTimer.scheduleAtFixedRate(new TimerTask() {
				public void run() {
					_doRegisterWithParent();
				}
			},
			0L, refreshInterval * 1000L );
		}
	}

	private DDNSNode addNodeToCache(DDNSNode node) {
		// don't cache if ttl==0, unless node is authoritative
		if ( mCacheTTL == 0 && !node.record().authoritative() ) return node;
		synchronized(mCache) {
			mCache.put(node.name(), node);
		}
		if ( mCacheTTL > 0 ) mTimer.schedule( new CacheCleaner(node.name()), (long)(mCacheTTL*1000) );
		return node;
	}
	
	private DDNSNode readNodeFromCache(DDNSFullName name) {
		synchronized(mCache) {
			return mCache.get(name);
		}
	}
	
	private DDNSNode deleteNameFromCache(DDNSFullName name) {
		synchronized(mCache) {
			DDNSNode node = mCache.get(name);
			mCache.remove(name);
			return node;
		}
	}
	
	/**
	 * Registers this host in the global ddns name tree.  ("This host" is the rpc service.)  Invoked periodically by update thread.
	 */
	private void _doRegisterWithParent() {
		try {
			RPCService rpcService = (RPCService)OS.getService("rpc"); 
			int myPort = rpcService.localPort();
			register(new DDNSFullName(OS.hostname()), myPort);
		} catch (Exception e) {
			Log.w(TAG, "ADVISORY: Caught exception while registering with parent:\n" + e.getMessage());
			e.printStackTrace();
		}
	}
	
	/**
	 * Unregisters a name.  
	 * @param name
	 * @throws DDNSException
	 */
	void unregister(DDNSFullName name) throws DDNSException {
		
		// unregister name in global ddns name tree
		DDNSNode ddnsServerNode = mRootServerNode;
		JSONObject args = null;
		try {
			args = new JSONObject().put("name", name.toString())
								   .put("password", mDDNSServicePassword);
		} catch (JSONException e) {
			throw new DDNSRuntimeException("_resolveFromRootServer caught JSONException: " + e.getMessage());
		}

		_serverIterateForUpdate(name, "unregister", args);
	}
	
	/**
	 * Registers a name as being on this host (IP) at the given port.
	 * If the name already exists, update its address mapping.  If it doesn't exist, create it (as an ARecord).
	 * @param name
	 * @param ip
	 * @param port
	 * @throws DDNSException
	 */
	void register(DDNSFullName name, int port) throws DDNSException {
		
		// figure out ip for registration
		RPCService rpc = (RPCService)OS.getService("rpc");
		if ( rpc == null ) throw new DDNSRuntimeException("No rpc service available.  Can't register '" + name + "'");
		String ip;
		try {
			ip = rpc.localIP();
		} catch (UnknownHostException e) {
			throw new DDNSRuntimeException("register(" + name + ") caught UnknownHostException: " + e.getMessage());
		}
		
		JSONObject args = null;
		try {
			args = new JSONObject().put("name", name.toString())
								   .put("ip", ip)
								   .put("port", port)
								   .put("password", mDDNSServicePassword);
		} catch (JSONException e) {
			throw new DDNSRuntimeException("register() caught JSONException: " + e.getMessage());
		}
		
		_serverIterateForUpdate(name, "register", args);
	}
	
	private void _serverIterateForUpdate(DDNSFullName name, String method, JSONObject args) throws DDNSException {
		
		// invalidate cache
		deleteNameFromCache(name);
		
		// register in the global name tree
		DDNSNode ddnsServerNode = mRootServerNode;
		if ( ddnsServerNode == null ) throw new DDNSNoAddressException(DDNSFullName.ROOTNAME);

		TTLCount resolveTTL = new TTLCount(maxTTL());

		DDNSNode node = null;
		while ( resolveTTL.count > 0) {

			if ( ddnsServerNode.isNegative() || ddnsServerNode.noSuchName() )
				throw new DDNSNoAddressException(name);
			try {
				node = _ddnsInvoke(resolveTTL, name, method, args, ddnsServerNode);
				if ( node == null )  // some server error...?
					throw new DDNSRuntimeException("Got null response to remote " + method + "(" + name + ")");
				node.record().setAuthoritative(false);
				addNodeToCache(node);
			} catch (DDNSNoSuchNameException nsne) {
				addNodeToCache( new DDNSNode(name, new ARecord()).setNoSuchName(true) );
				throw nsne;
			} catch (DDNSNoAddressException nae) {
				addNodeToCache( new DDNSNode(name, new ARecord()).setIsNegative(true) );
				throw nae;
			}

			RRType nodeType = node.record().type();
			if ( nodeType == RRType.RRTYPE_A || nodeType == RRType.RRTYPE_SOA ) return;
			if ( nodeType == RRType.RRTYPE_NS ) ddnsServerNode = node;   // need to follow the link
			else if ( nodeType == RRType.RRTYPE_CNAME ) {
				name = ((CNAMERecord)node.record()).alias();
				try {
					args.put("name", name.toString());
				} catch (JSONException e) {
					throw new DDNSRuntimeException("serverIterate caught JSONException: " + e.getMessage());
				}
			}
		}
		throw new DDNSTTLExpiredException(name);
	}
	
	/**
	 * Resolves a name to an ARecord containing an address.  Throws an exception if no ARecord w/ address can be found.
	 * @param name
	 * @return The ARecord for the name, if one is found
	 * @throws DDNSException
	 */
	public ARecord resolve(String nameStr) throws DDNSException {
		// Responsibilties of this routine: Convert from DDNSNode to ARecord
		
		DDNSFullName name = new DDNSFullName(nameStr);
		
		DDNSNode resultNode = _resolveFromRootServer(name);
		
		// null shouldn't be possible, but some broken server might return void
		if ( resultNode == null || resultNode.record() == null ) {
			Log.e(TAG, "resolve(" + name + ") got null record");
			throw new DDNSRuntimeException("Got null response resolving name '" + name + "'");
		}
		if ( resultNode.isNegative() ) throw new DDNSNoAddressException(name);
		
		ARecord aRecord = null;
		try {
			// if the record isn't an address record, the cast will cause an exception
			aRecord = (ARecord)resultNode.record(); 
		} catch (Exception e ) {
			Log.e(TAG,"Got odd record from _resolveToNode(" + name + "): " + resultNode.record().toString());
			throw new DDNSNoAddressException(name);
		}
		return aRecord;
	}
	
	private DDNSNode _resolveFromRootServer(DDNSFullName originalName) throws DDNSException {
		// Responsiblities of this method: check cache for hits; orchestrate search across DDNS servers; insert elements into cache
		
		// set up in case we need to query a server
		DDNSNode ddnsServerNode = mRootServerNode;
		
		DDNSFullName name = new DDNSFullName( originalName.toString() );
		
		TTLCount resolveTTL = new TTLCount(maxTTL());
		
		DDNSNode node = null;
		while ( resolveTTL.count > 0) {
			
			node = readNodeFromCache(name);
			if ( node != null ) {
				mCacheHits++;
				resolveTTL.count--;
				if ( node.isNegative()) throw new DDNSNoAddressException(name);
				if ( node.noSuchName() ) throw new DDNSNoSuchNameException(name);
			}
			else {
				mCacheMisses++;
				if ( ddnsServerNode.isNegative() || ddnsServerNode.noSuchName() )
					throw new DDNSNoAddressException(name);
				try {
					JSONObject args;
					try {
						args = new JSONObject().put("name", name.toString());
					} catch (JSONException e) {
						throw new DDNSRuntimeException("_resolveFromRootServer caught JSONException: " + e.getMessage());
					}
					node = _ddnsInvoke(resolveTTL, name, "resolve", args, ddnsServerNode);
					if ( node == null )  // some server error...?
						throw new DDNSRuntimeException("Got null response to remote resolve(" + name + ")");
					
					// caching is dangerous -- the remote server may be buggy.  But, the cache is cleaned periodically...
					//TODO: can result.node.record be null?
					node.record().setAuthoritative(false);
					addNodeToCache(node);
					
				} catch (DDNSNoSuchNameException nsne) {
					addNodeToCache( new DDNSNode(name, new ARecord()).setNoSuchName(true) );
					throw nsne;
				} catch (DDNSNoAddressException nae) {
					addNodeToCache( new DDNSNode(name, new ARecord()).setIsNegative(true) );
					throw nae;
				}
			}

			//TODO: node.record == null?
			RRType nodeType = node.record().type();
			if ( nodeType == RRType.RRTYPE_A || nodeType == RRType.RRTYPE_SOA ) return node;
			if ( nodeType == RRType.RRTYPE_NS ) ddnsServerNode = node;   // need to follow the link
			else if ( nodeType == RRType.RRTYPE_CNAME ) name = ((CNAMERecord)node.record()).alias();
		}
		throw new DDNSTTLExpiredException(name);
	}

	/**
	 * Handles talking with one DDNS server, which pursues name until either it finds it or
	 * encounters a leaf.  
	 * 
	 * @param result  The node and remaining count are passed back through this argument.
	 * @param name
	 * @param requestMethod
	 * @param requestArgs
	 * @param ddnsServerNode
	 * @return
	 * @throws DDNSException
	 */
	private DDNSNode _ddnsInvoke(TTLCount resolveTTL, DDNSFullName name, String requestMethod, JSONObject requestArgs, DDNSNode ddnsServerNode) 
			throws DDNSException {
		
		JSONObject responseObj;
		try {
			if ( ddnsServerNode.isNegative() ) throw new DDNSNoAddressException( ddnsServerNode.name() );
			ARecord serverAddressRecord = (ARecord)ddnsServerNode.record();
			
			requestArgs.put( "resolvettl", resolveTTL.count );  // update the request args
			
			Log.d(TAG, "Contacting server at " + serverAddressRecord.ip() + " : " + serverAddressRecord.port());
			
			RPCCallerSocket socket = new RPCCallerSocket( ddnsServerNode.name().toString(),
		                                                  serverAddressRecord.ip(),
		                                                  serverAddressRecord.port()
						                                );
			responseObj = socket.invoke( "ddns", requestMethod, requestArgs);
			return DDNSResponse.unmarshall(responseObj, resolveTTL );

		} catch (JSONException je) {
			throw new DDNSRuntimeException("Likely malformed response message: " + je.getMessage());
		} catch (IOException e) {
			throw new DDNSNoAddressException(name); // can contact server - name may or may not exist, but we can't get an address
		}
	}
	
	
	int maxTTL() {
		return mMaxResolutionTTL;
	}
	
	public String toString(String prefix) {
		StringBuilder sb = new StringBuilder();
		return _toString(sb, prefix).toString();
	}
	
	public StringBuilder _toString(StringBuilder sb, String prefix) {
		sb.append(mCacheMisses).append(" misses\n")
		  .append(mCacheHits).append(" hits\n");
		synchronized(mCache) {
			for ( DDNSNode node : mCache.values() ) {
				node._toString(sb, prefix);
			}
		}
		return sb;
	}
}
