package edu.uw.cs.cse461.sp12.OS;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Timer;
import java.util.TimerTask;

import org.json.JSONException;
import org.json.JSONObject;

import edu.uw.cs.cse461.sp12.OS.DDNSException.DDNSAuthorizationException;
import edu.uw.cs.cse461.sp12.OS.DDNSException.DDNSNoAddressException;
import edu.uw.cs.cse461.sp12.OS.DDNSException.DDNSNoSuchNameException;
import edu.uw.cs.cse461.sp12.OS.DDNSException.DDNSRuntimeException;
import edu.uw.cs.cse461.sp12.OS.DDNSRRecord.ARecord;

/**
 * A DDNSNode represents just the information that can go on the wire.
 * @author zahorjan
 *
 */
class DDNSNode {
	protected DDNSFullName mName;
	protected DDNSRRecord mRecord;
	protected boolean mIsNegative;


	//-----------------------------------------------------------------------------------------
	//-----------------------------------------------------------------------------------------
	/**
	 * DDNSTreeNode is used by DDNSService to maintain its portion of the global name tree.
	 * @author zahorjan
	 *
	 */
	static class DDNSTreeNode extends DDNSNode {
		private static final String TAG="DDNSTreeNode";
		private String mPassword;
		private TimerTask mCleanTask;
		private HashMap<DDNSFullName, DDNSTreeNode> mChildren;
		
		DDNSTreeNode(DDNSFullName name, String password, DDNSRRecord record) {
			super(name, record);
			mCleanTask = null;
			mPassword = password;
			mChildren = new HashMap<DDNSFullName,DDNSTreeNode>();
		}
		synchronized DDNSTreeNode child(DDNSFullName name) {
			return mChildren.get(name);
		}
		synchronized DDNSTreeNode addChild(DDNSTreeNode node, String password) throws DDNSAuthorizationException {
			_checkAuth(password);
			mChildren.put(node.name(), node);
			return node;
		}
		synchronized DDNSTreeNode updateAddress(String ip, int port, String password, Timer timer, int cleanInterval) throws DDNSAuthorizationException {
			_checkAuth(password);
			// there's a race with a possibly running cleaner task, but it's really cumbersome to deal with and not
			// very destructive, so we ignore it.  But, we try to cancel any such task as early as possible.
			if ( mCleanTask != null ) mCleanTask.cancel();
			mCleanTask = null;
			if ( cleanInterval > 0 ) {
				mCleanTask = new TimerTask() {
					public void run() {
						((DDNSRRecord.ARecord)record()).updateAddress(null,  -1);
						mIsNegative = true; 
					}
				};
				timer.schedule( mCleanTask, cleanInterval * 1000);
			}
			((DDNSRRecord.ARecord)record()).updateAddress(ip,  port);
			mIsNegative = _evaluateNegative(mRecord);
			return this;
		}
		private void _checkAuth(String password) throws DDNSAuthorizationException {
			// null password semantics?  no access...
			if ( mPassword == null || !mPassword.equals(password) ) {
				throw new DDNSAuthorizationException(name());		
			}
		}
		synchronized void _toString(StringBuilder sb, String prefix) {
			super._toString(sb,  prefix);
			prefix += "   ";
			List<DDNSFullName> children = new ArrayList<DDNSFullName>(mChildren.keySet());
			Collections.sort(children);
			for ( DDNSFullName childname : children ) {
				mChildren.get(childname)._toString(sb,  prefix);
			}
		}
	}
	
	static class DDNSCacheNode extends DDNSNode {
		protected boolean mNoSuchName;
		
		public DDNSCacheNode(DDNSFullName name, DDNSRRecord record) {
			super(name, record);
			mNoSuchName = false;
		}
		
		public DDNSCacheNode(JSONObject jsonObj) throws JSONException, DDNSRuntimeException {
			super(jsonObj);
			mNoSuchName = false;
		}
		
		@Override
		boolean noSuchName() { return mNoSuchName; }
		DDNSCacheNode setNoSuchName(boolean b) { mNoSuchName = b; return this; }
		
		void _toString(StringBuilder sb, String prefix) {
			super._toString(sb,  prefix);
		}
	}

	//-----------------------------------------------------------------------------------------
	//-----------------------------------------------------------------------------------------
	
	public DDNSNode(DDNSFullName name, DDNSRRecord record) {
		mName = name;
		mRecord = record;
		mIsNegative = _evaluateNegative(record);
	}
	
	private static boolean _evaluateNegative(DDNSRRecord record) {
		try {
			return record == null || ((ARecord)record).ip()==null; 
		} catch (Exception e) {
			// most likely, record isn't an ARecord
			return false;
		}
	}
	
	public DDNSNode(JSONObject jsonObj) throws JSONException, DDNSRuntimeException {
		// we don't actually send mIsNegative or mNoSuchName -- if either is true, an exception is sent, not a DDNSNode
		mIsNegative = false;
		mName = new DDNSFullName( jsonObj.getString("name") );
		mRecord = DDNSRRecord.unmarshall(jsonObj);
	}

	JSONObject marshall() throws JSONException, DDNSNoAddressException, DDNSNoSuchNameException {
		JSONObject obj;
		if ( isNegative() ) throw new DDNSNoAddressException( name() );
		if ( mRecord != null ) obj = mRecord.marshall();
		else obj = new JSONObject();
		return obj.put("name", mName.toString());
	}
	
	DDNSFullName name() { return mName; }
	final DDNSRRecord record() { return mRecord; }
	
	boolean isNegative() { return mIsNegative; }
	DDNSNode setIsNegative(boolean b) { mIsNegative = b; return this; }
	
	// to establish this method for _toString().  Overriden by DDNSCacheNode
	boolean noSuchName() { return false; }
	
	/**
	 * toString using a StringBuilder
	 * @param sb
	 * @param prefix
	 */
	void _toString(StringBuilder sb, String prefix) {
		sb.append(prefix).append('\'').append(name()).append('\'').append("\t");
		if ( noSuchName() ) sb.append("[NoSuchName]\n");
		else if ( isNegative() ) sb.append("[No current address]\n");
		else if ( mRecord != null ) {
			sb.append("[");
			mRecord._toString(sb);
			sb.append("]\n");
		}
	}

	public String toString(String prefix) {
		StringBuilder sb = new StringBuilder();
		_toString(sb, prefix);
		return sb.toString();
	}
}

