package edu.uw.cs.cse461.Net.DDNS;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.io.Writer;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import org.json.JSONException;
import org.json.JSONObject;

import edu.uw.cs.cse461.HTTP.HTTPProviderInterface;
import edu.uw.cs.cse461.Net.Base.NetBase;
import edu.uw.cs.cse461.Net.Base.NetLoadable.NetLoadableService;
import edu.uw.cs.cse461.Net.DDNS.DDNSException.DDNSAuthorizationException;
import edu.uw.cs.cse461.Net.DDNS.DDNSException.DDNSNoSuchNameException;
import edu.uw.cs.cse461.Net.DDNS.DDNSException.DDNSRuntimeException;
import edu.uw.cs.cse461.Net.DDNS.DDNSException.DDNSTTLExpiredException;
import edu.uw.cs.cse461.Net.DDNS.DDNSException.DDNSZoneException;
import edu.uw.cs.cse461.Net.DDNS.DDNSNode.DDNSTreeNode;
import edu.uw.cs.cse461.Net.DDNS.DDNSRRecord.ARecord;
import edu.uw.cs.cse461.Net.DDNS.DDNSRRecord.CNAMERecord;
import edu.uw.cs.cse461.Net.DDNS.DDNSRRecord.NSRecord;
import edu.uw.cs.cse461.Net.DDNS.DDNSRRecord.RRType;
import edu.uw.cs.cse461.Net.DDNS.DDNSRRecord.SOARecord;
import edu.uw.cs.cse461.Net.DDNS.DDNSServiceRPCStub.DDNSServiceRegisterStub;
import edu.uw.cs.cse461.Net.DDNS.DDNSServiceRPCStub.DDNSServiceResolveStub;
import edu.uw.cs.cse461.Net.DDNS.DDNSServiceRPCStub.DDNSServiceUnregisterStub;
import edu.uw.cs.cse461.Net.RPC.RPCCallableMethod;
import edu.uw.cs.cse461.Net.RPC.RPCService;
import edu.uw.cs.cse461.util.ConfigManager;
import edu.uw.cs.cse461.util.Log;

/**
 * Protocol: Based on RPC.  The calls:
 * <p>
 * Request:  method: "register" 
 *           args: 
 * <br>Response:  void
 * <p>
 * Fetch all records (for all apps) for a specific host.
 * Request:  method: "fetchall"
 *           args:  {host: hostname}
 * <br>Response:  [ [appname, port, authoritative], ...]
 *
 * <pre>
 * app:"ddns" supports RPC calls:
 *     register( {host: hostname,  ip: ipaddr,   port: portnum} ) => { status: "OK" } or errormsg
 *     resolve( { host: hostname } ) => { host: repeats hostname, ip: ip address, authoritative: boolean } ) or errormsg
 * </pre>
 * 
 *  * @author zahorjan
 *
 */
public class DDNSService extends NetLoadableService implements HTTPProviderInterface, DDNSServiceInterface {
	private static String TAG="DDNSService";
	
	// how often to re-read the ddns.nodefile file
	private static final int READNODEFILE_INTERVAL = 5 * 60 * 1000;  // 5 minutes
	
	// how long a registered address should survive before being set to no address
	private static final int DEFAULTCLEANINTERVAL = 300;
	private static final int MINIMUMCLEANINTERVAL = 10;
	private int mCleanInterval;
	private Timer mTimer;
	
	private DDNSTreeNode mRoot;  // root of name tree
	private DDNSFullNameInterface mMyZone; // root name of my zone
	private String mMyPassword;
	
	// how many steps to take searching for a name in this zone
	private static final int DEFAULTRESOLUTIONSTEPS = 50;
	private static final int MAXRESOLUTIONSTEPS = 300;
	private int mMaxResolutionSteps;
	
	private RPCCallableMethod resolve;
	private RPCCallableMethod register;
	private RPCCallableMethod unregister;

	public static class ResultObject extends DDNSResultObject {
		int mTTL;
		ResultObject(int ttl, int cleanInterval) {
			super(cleanInterval);
			mTTL = ttl;
		}
		DDNSTreeNode node() {
			return (DDNSTreeNode)mNode;
		}
	}
	
	/**
	 * This class implements a daemon that periodically reads a zone file and ensures that the records it
	 * describes exist in this name server.  The zone file may be named by the ddns.nodefile entry in the
	 * config file, or it could be the config file itself (when there is no ddns.nodefile property in the config file).
	 */
	private class RecordRefreshDaemon extends TimerTask {
		private File mNodeFile = null;

		RecordRefreshDaemon() throws IOException {
			ConfigManager config = NetBase.theNetBase().config();
			String nodeFilename = config.getProperty("ddns.nodefile");
			if ( nodeFilename == null ) return;  // look for node initialization data in the config file itself
			mNodeFile = new File(config.getProperty("config.directory"), nodeFilename);
			if ( !mNodeFile.exists() || !mNodeFile.canRead() ) throw new IOException("DDNS node file " + mNodeFile.getCanonicalPath() +
					                                                                 " doesn't exist or isn't readable.");
		}
		
		/**
		 * Returns true iff there is a ddns.nodefile entry in the config file and the file it names could
		 * be read at the time this RecordRefreshDaemon was constructed.
		 * @return
		 */
		public boolean hasNodeFile() { return mNodeFile != null; }

		public void run() {

			ConfigManager config;
			FileInputStream fis = null;
			
			Log.e(TAG, "Reading node file data");

			try {

				if ( mNodeFile == null ) config = NetBase.theNetBase().config();
				else config = new ConfigManager(new FileInputStream(mNodeFile));

				RPCService rpcService = (RPCService)NetBase.theNetBase().getService("rpc");
				String myIP = rpcService.localIP();
				int myPort = rpcService.localPort();

				//--------------------------------------------------------------
				// ddns.nodes
				// Add names configured in the config file
				//   Entries in config file are <recordtype>:<nameservername>:<password to update this record>
				//--------------------------------------------------------------

				Vector<String[]> recordVec = config.readNameRecordVec("ddns.nodes");

				boolean firstRecord = true;
				for (String[] entry : recordVec ) {
					DDNSRRecord record = null;
					String type = entry[0].toLowerCase();
					DDNSFullName name = new DDNSFullName(entry[1]);
					String password = entry[entry.length-1];

					// the soa record must be the first one into the tree
					if ( firstRecord && !type.equals("soa") ) throw new DDNSRuntimeException("First node in ddsn.nodes in config file must be SOA");

					if ( type.equals("a") ) record = new ARecord();
					else if ( type.equals("ns") ) record = new NSRecord();
					else if ( type.equals("soa")) {
						if ( !firstRecord ) throw new DDNSRuntimeException("ddns.nodes contains SOA record that's not the first name defined: " + name );
						record = new SOARecord(myIP, myPort);
						mMyZone = name;
						mMyPassword = password;
					}
					else if ( type.equals("cname")) {
						record = new CNAMERecord(entry[2]);
					}
					else throw new DDNSRuntimeException("Unrecognized record type (" + type + ") in ddns.nodes in config file");

					// don't have to execute synchronized here because we're in the constructor
					_addName( new DDNSTreeNode( name, password, record), mMyPassword );
					
					firstRecord = false;
				}

				//--------------------------------------------------------------
				// DEPRECATED:
				// ddns.nslist
				// Add nodes from ddns.nslist.  These are the student ns and
				// www required to link their zones to the root
				// Each entry in the config file is like 
				//      jz.cse461.:password
				// which generates two records:
				//   a:jz.cse461.:password
				//   a:jz.cse461.www.:password
				//--------------------------------------------------------------

				int zoneLength = zone().toString().length();
				recordVec = config.readNamePasswordVec("ddns.nslist");
				for (String[] entry : recordVec ) {
					DDNSFullName name = new DDNSFullName(entry[0]);
					String password = entry[1];

					_addName( new DDNSTreeNode(name, password, new NSRecord()), mMyPassword );
					String wwwName = name.toString().substring(0, name.toString().length()-zoneLength);
					name = new DDNSFullName(wwwName.toString() + "www." + zone().toString());
					_addName( new DDNSTreeNode(name, password, new ARecord()), mMyPassword );
				}

				//--------------------------------------------------------------
				// ddns.init
				// Perform any requested address initialization.  Most often this
				// is useful only for grading -- set up a branch of the name space
				// with consed up IPs and check that student code resolves them
				// correctly.
				//
				// Form 
				//    name:IP
				// Used primarily to initialize a zone for grading purposes
				// (submit.test.cse461.).
				//--------------------------------------------------------------

				recordVec = config.readNameIPPortVec("ddns.init");
				for (String[] entry : recordVec ) {
					register(new DDNSFullName(entry[0]), entry[1], Integer.parseInt(entry[2]), mMyPassword);
				}
			} catch (Exception e) {
				Log.w(TAG, "Caught " + e.getClass().getName() + " exception: " + e.getMessage());
			} finally {
				if ( fis != null ) try { fis.close(); } catch (Exception e) {}
			}
		}
	}

	/**
	 * Called to end execution.  Specifically, need to terminate any threads we've created.
	 */
	@Override
	public void shutdown() {
		if ( mTimer != null ) mTimer.cancel();
		mTimer = null;

		super.shutdown();
	}
	
	@Override
	public String httpServe(String[] uriArray) { return toString();	}
	
	/**
	 * Constructor.  Registers the system RPCServerSocket with the parent as
	 * this host's ip address.  Registers the root server and itself in the
	 * local name cache.
	 * @throws DDNSException
	 */
	public DDNSService() throws DDNSException {
		super("ddns", true);
		
		try {
			mRoot = null;
			mTimer = new Timer();
			
			//--------------------------------------------------------------
			// get this host's address
			//--------------------------------------------------------------

			RPCService rpcService = (RPCService)NetBase.theNetBase().getService("rpc");
			String myIP = rpcService.localIP();
			int myPort = rpcService.localPort();
			Log.d(TAG, "myAddress = " + myIP + ":" + myPort);
			
			//--------------------------------------------------------------
			// Find max steps to take during resolve
			//--------------------------------------------------------------
			
			mMaxResolutionSteps = NetBase.theNetBase().config().getAsInt("ddns.resolvettl", DEFAULTRESOLUTIONSTEPS, 10, MAXRESOLUTIONSTEPS, TAG); 

			//--------------------------------------------------------------
			// At this point we want to populate the server with initial data
			// before proceeding with other initialization.
			// We want to periodically update the initial data initialization
			// as well.
			//--------------------------------------------------------------
			
			RecordRefreshDaemon refreshDaemon = new RecordRefreshDaemon();
			refreshDaemon.run();
			if ( refreshDaemon.hasNodeFile() ) 	mTimer.schedule(refreshDaemon, READNODEFILE_INTERVAL, READNODEFILE_INTERVAL);
			
			//--------------------------------------------------------------
			// establish clean interval
			//--------------------------------------------------------------
			
			mCleanInterval = NetBase.theNetBase().config().getAsInt("ddns.cleaninterval", DEFAULTCLEANINTERVAL, MINIMUMCLEANINTERVAL, TAG);
			
			//--------------------------------------------------------------
			// set up RPC callable methods
			//--------------------------------------------------------------

			// export methods via the rpc service
			resolve = new RPCCallableMethod(this, "_rpcResolve");
			register = new RPCCallableMethod(this, "_rpcRegister");
			unregister = new RPCCallableMethod(this, "_rpcUnregister");

			rpcService.registerHandler(loadablename(), "register", register );
			rpcService.registerHandler(loadablename(), "unregister", unregister );
			rpcService.registerHandler(loadablename(), "resolve", resolve );
			
			Log.d(TAG, "Starting ddns service for zone '" + zone() + "' on host '" + NetBase.theNetBase().hostname() + "' on port " + myPort);
			Log.d(TAG, toString());
			
		} catch (Exception e) {
			String msg = "DDNSService constructor caught exception: " + e.getMessage();
			Log.e(TAG, msg);
			e.printStackTrace();
			throw new DDNSRuntimeException(msg);
		}
	}
	
	private DDNSFullNameInterface zone() { 
		return this.mMyZone;
	}
	
	//---------------------------------------------------------------------------------------------------------------------------
	// name tree manipulation
	
	/**
	 * This routine injects new names into the tree.  It turns out to be handy to allow injection of names
	 * that are not immediate children of any existing node.  When that happens, we create the missing nodes,
	 * setting them up as negative A records.
	 *
	 * @param result  Structure for passing in resolve TTL, and returning node found and remaining TTL  
	 * @param node
	 * @param password
	 * @throws DDNSRuntimeException
	 * @throws DDNSTTLExpiredException
	 * @throws DDNSZoneException
	 * @throws DDNSAuthorizationException
	 */
	private DDNSTreeNode _addName(DDNSTreeNode node, String password)
			throws DDNSRuntimeException, DDNSTTLExpiredException, DDNSZoneException, DDNSAuthorizationException {

		//NOTE: If root is null, we never check authorization!
		if ( mRoot == null ) {
			mRoot = node;
			return node;
		}
		
		ResultObject resultObj = new ResultObject(mMaxResolutionSteps, mCleanInterval);
		_findLast(resultObj, node.name());
		DDNSTreeNode lastNode = resultObj.node(); 
		
		// node exists
		// Before we started reading the zone file repeatedly, this was an error
		if ( lastNode.name().equals(node.name()) ) return lastNode.setPassword(password); 
		                                           // throw new DDNSRuntimeException("addNode: Node " + node.name() + " already exists");

		// found a node leading us out of our zone
		if ( lastNode.record().type() == RRType.RRTYPE_NS ) throw new DDNSZoneException(node.name(), zone());
		// can't add nodes below a CNAME
		if ( lastNode.record().type() == RRType.RRTYPE_CNAME ) throw new DDNSRuntimeException("Can't create nodes below CNAMEs");
		
		// need to create intermediary node(s)?
		while (	resultObj.mTTL > 0 && !node.name().parent().equals(resultObj.mNode.name()) ) {
			DDNSTreeNode newNode = new DDNSTreeNode( resultObj.node().name().nextAncestor(node.name()), password, new ARecord(null, -1));
			resultObj.node().addChild(newNode, password);
			resultObj.mNode = newNode;
			resultObj.mTTL--;
		}

		// found immediate parent
		resultObj.node().addChild(node, password);   // auth check happens here
		return node;
	}
	
	/**
	 * Resolve name as far as possible, and return node you end up on.
	 * 
	 * @param result  Return structure; contains node and remaining TTL count. The node is 
	 * the last node visited in the search.  Could be the node with the given name.  Could be a leaf ancestor of that node.
	 * Could be that the TTL expried and it's an arbitrary node.
	 * @param fullname
	 * @throws DDNSTTLExpiredException
	 * @throws DDNSRuntimeException
	 */
	private void _findLast(ResultObject resultObj, DDNSFullNameInterface fullname) throws DDNSTTLExpiredException, DDNSRuntimeException {
		String name = fullname.toString();
		String suffix = mRoot.name().toString();
		if ( !name.endsWith(suffix) ) throw new DDNSRuntimeException("Node " + name + " isn't in this zone [" + suffix + "]");
		
		name = name.substring(0, name.length() - suffix.length() );
		String[] token = name.split("\\.");
		
		//TODO: Handle CNAMEs...
		
		resultObj.mNode = mRoot;
		if ( resultObj.mNode == null ) throw new DDNSRuntimeException("_findLast called when the tree is empty");
		DDNSTreeNode nextNode;
		for ( int index = token.length-1; index >= 0; index-- ) {
			if (resultObj.mNode.record().type() == RRType.RRTYPE_CNAME ) return;
			nextNode = resultObj.node().child(new DDNSFullName(token[index] + "." + resultObj.mNode.name()));
			if ( nextNode == null ) return;
			if ( --resultObj.mTTL <= 0 ) throw new DDNSTTLExpiredException(fullname);
			resultObj.mNode = nextNode;
		}
	}
	
	//---------------------------------------------------------------------------
	// RPC callable routines
	
	/**
	 * Indicates host is going offline.
	 *      unregister( {name: name, password: password} ) => { status: "OK" } or errormsg
	 * @param args
	 * @return
	 * @throws JSONException
	 * @throws DDNSException
	 */
	public JSONObject _rpcUnregister(JSONObject args) {
		// can't just invoke _rpcRegister with ip -> null because of JSONObject except issues regarding null
		try {
			DDNSFullName name = new DDNSFullName(args.getString("name"));
			String password = args.getString("password");
			ResultObject resultObj = register(name, null, -1, password);
			return DDNSServiceUnregisterStub.marshall(resultObj); // void return
		} catch (DDNSException e) {
			return DDNSResultObject.marshall(e);
		} catch (JSONException ee) {
			return DDNSResultObject.marshall( new DDNSRuntimeException("Likely malformed call arguments: " + args.toString() +
																		"\nJSONException message: " + ee.getMessage()) );
		} catch (Exception e) {
			final Writer trace = new StringWriter();
			final PrintWriter printWriter = new PrintWriter(trace);
			e.printStackTrace(printWriter);
			Log.e(TAG, "_rpcUnregister caught unanticipated Exception: " + e.getMessage() + "\n" + trace.toString());
			return DDNSResultObject.marshall( new DDNSRuntimeException("Internal error: " + e.getMessage()) );
		}
	}
	
	/**
	*   register( {name: <string>, password: <string>, ip: <string>,  port: <int>} ) => { DDNSNode } or errormsg
	*<p>
	* We accept only requests for names stored on this server.
	* 
	* @param args
	* @return
	*/
	public JSONObject _rpcRegister(JSONObject args) {
		try {
			Log.i(TAG, "_rpcRegister(" + args + ")");
			
			DDNSFullName name = new DDNSFullName(args.getString("name"));
			String ip = (String)args.get("ip");   // getString throws an exception if the value associated with key "ip" is null
			int port = args.getInt("port");
			String password = args.getString("password");
			ResultObject resultObj = register(name, ip, port, password);
			return DDNSServiceRegisterStub.marshall(resultObj);
		} catch (DDNSException e) {
			return DDNSResultObject.marshall(e);
		} catch (JSONException ee) {
			return DDNSResultObject.marshall( new DDNSRuntimeException("Likely malformed call arguments: " + args.toString() +
																		"\nJSONException message: " + ee.getMessage()) );
		} catch (Exception e) {
			final Writer trace = new StringWriter();
			final PrintWriter printWriter = new PrintWriter(trace);
			e.printStackTrace(printWriter);
			Log.e(TAG, "_rpcRegister caught unanticipated Exception: " + e.getMessage() + "\n" + trace.toString());
			return DDNSResultObject.marshall( new DDNSRuntimeException("Internal error: " + e.getMessage()) );
		}
	}
	
	/**
	 * This version is invoked via RPC.  It's simply a wrapper that extracts the call arguments
	 * and invokes resolve(host).
	 * @param callArgs
	 * @return
	 */
	public JSONObject _rpcResolve(JSONObject args) {
		Log.i(TAG, "_rpcResolve(" + args + ")");
		
		// resolve calls don't require passwords
		try {
			String nameStr = args.getString("name");
			DDNSFullNameInterface name = new DDNSFullName(nameStr);
			
			ResultObject resultObj = resolve(name); 
			return DDNSServiceResolveStub.marshall(resultObj);
			
		} catch (DDNSException de) {
			return DDNSResultObject.marshall(de);
		} catch (JSONException ee) {
			return DDNSResultObject.marshall( new DDNSRuntimeException("Likely malformed call arguments: " + args.toString() +
																		"\nJSONException message: " + ee.getMessage()) );
		} catch (Exception e) {
			final Writer trace = new StringWriter();
			final PrintWriter printWriter = new PrintWriter(trace);
			e.printStackTrace(printWriter);
			Log.e(TAG, "_rpcResolve caught unanticipated Exception: " + e.getMessage() + "\n" + trace.toString());
			return DDNSResultObject.marshall( new DDNSRuntimeException("Internal error: " + e.getMessage()) );
		}
	}
	
	// RPC callable routines
	//---------------------------------------------------------------------------

	/**
	 * Resolves a name to a DDNSNode, recursing into other servers if required.  The name must
	 * be a descendent of this server's zone.
	 * @param name  The name to resolve
	 * @param resolveTTL Resolution step limit
	 * @return 
	 * @throws DDNSRuntimeException
	 */
	private ResultObject resolve(DDNSFullNameInterface name) throws DDNSNoSuchNameException, DDNSRuntimeException {
		Log.d(TAG, "Resolve(" + name + ")");

		try {
			ResultObject resultObj = new ResultObject(mMaxResolutionSteps, mCleanInterval);
			synchronized(this) {
				_findLast(resultObj, name);
			}

			DDNSRRecord responseRecord = resultObj.mNode.record();
			switch(responseRecord.type()) {
			case RRTYPE_A:
			case RRTYPE_SOA:
								if ( !resultObj.mNode.name().equals(name) ) throw new DDNSNoSuchNameException(name);
								resultObj.mDone = true;
								return resultObj;
								
			case RRTYPE_CNAME:
								return resultObj;
								
			case RRTYPE_NS:
								return resultObj;
								
			default:
								throw new DDNSRuntimeException("Encountered node of type " + responseRecord.type() + " resolving name '" + name + "'");
			}
			
		} catch (DDNSNoSuchNameException dnsne) {
			Log.e(TAG, dnsne.getMessage());
			throw dnsne;
		} catch (DDNSRuntimeException dre) {
			Log.e(TAG, dre.getMessage());
			throw dre;
		} catch (Exception e) {
			String msg = "resolve(" + name + "): " + e.getMessage();
			Log.e(TAG, msg);
			throw new DDNSRuntimeException(msg);
		}
	}
	
	/**
	 * Update address mapping for an existing name.
	 * Works only on names stored locally -- no forwarding is done, except for SOA records,
	 * in which case the parent zone is notified.
	 * 
	 * @param name Name to update
	 * @param ip New ip address
	 * @param port New port
	 * @param password Password for the node
	 * @return The updated node
	 * @throws DDNSTTLExpiredException
	 * @throws DDNSNoSuchNameException
	 * @throws DDNSRuntimeException
	 */
	private ResultObject register(DDNSFullName name, String ip, int port, String password)
			throws DDNSTTLExpiredException, DDNSNoSuchNameException, DDNSRuntimeException, DDNSAuthorizationException, DDNSZoneException {
		Log.d(TAG, "register(" + name + ", " + ip + ", " + port + ")");
		
		ResultObject resultObj = new ResultObject(mMaxResolutionSteps, mCleanInterval);
		synchronized(this) {
			_findLast(resultObj, name);
		}

		if ( resultObj.mNode != null ) {
			// existing node
			switch( resultObj.mNode.record().type()) {
			case RRTYPE_NS:		// NS may be what we want to update, or we're just passing through.
								// Eventually, caller must pursue next server (to update SOA or to continue name resolution)
								if ( resultObj.mNode.name().equals(name) ) resultObj.node().updateAddress( ip, port, password, mTimer, mCleanInterval);
								break;
			case RRTYPE_SOA:
			case RRTYPE_A:		if ( resultObj.mNode.name().equals(name) ) {
									resultObj.node().updateAddress( ip, port, password, mTimer, mCleanInterval);
									resultObj.mDone = true;
								}
								else resultObj.mNode = null;  // indicate name not found to code below
								break;

			case RRTYPE_CNAME:	// have to return CNAME to caller to re-eval, as it may be in another zone
								break;
			}
		}
		
		if ( resultObj.mNode == null) {
			// create node, including any required ancestors
			resultObj.mNode = new DDNSTreeNode(name, password, new ARecord(ip, port) );
			_addName(resultObj.node(), password).updateAddress( ip, port, password, mTimer, mCleanInterval );
			resultObj.mDone = true;
		}
		
		return resultObj;
	}
	
	@Override
	public String dumpState() {
		return toString();
	}
	
	/**
	 * The usual toString.
	 */
	public String toString() {
		StringBuilder sb = new StringBuilder();
		String zone = NetBase.theNetBase().hostname();
		sb.append("Zone: ");
		if ( zone != null ) sb.append(zone).append("\n");
		else sb.append("undefined\n");
		
		mRoot._toString(sb,  "");
		return sb.toString();
	}

}
