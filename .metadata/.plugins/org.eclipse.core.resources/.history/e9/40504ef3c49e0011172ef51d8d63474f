package edu.uw.cs.cse461.sp12.OS;

import org.json.JSONException;
import org.json.JSONObject;

import edu.uw.cs.cse461.sp12.OS.DDNSException.DDNSRuntimeException;
import edu.uw.cs.cse461.sp12.OS.DDNSServiceRPCStub.DDNSServiceRegisterStub;
import edu.uw.cs.cse461.sp12.OS.DDNSServiceRPCStub.DDNSServiceResolveStub;
import edu.uw.cs.cse461.sp12.OS.DDNSServiceRPCStub.DDNSServiceUnregisterStub;
import edu.uw.cs.cse461.sp12.util.Log;

/**
 * All DDNSService RPC class return almost the same thing.  This class represents
 * the union of those things.
 * <p>
 * There are two sides to this.  The DDNSService uses one of these one of these to
 * accumulate its response.  It then calls the appropriate marshall() routine in
 * DDNSServiceRPCStub to convert it to a JSONObject for transmission over the wire.
 * <p>
 * The caller side invokes the method-specific call() method, which makes the RPC,
 * gets back the JSON object, and ands that to the constructor here to create
 * one of these to give the actual client caller.
 * <p>
 * (So, both marshall and unmarshall happen in the DDNSServiceRPCStub code.)
 *  
 * @author zahorjan
 *
 */
class DDNSResultObject {
	private final static String TAG="DDNSResponse";
	
	DDNSNode mNode;  // holds a TreeNode in DDNSService code, a CacheNode in DDNSResolver code
	boolean mDone;   // true if operation reached the named node; false if it didn't
	int mLifetime;
	
	//------------------------------------------------------------------------------------
	//------------------------------------------------------------------------------------
	// Callee (DDNSService) side methods
	
	/**
	 * Constructor for callee (DDNSService) side.
	 * 
	 * @param ttl
	 * @param cleanInterval
	 */
	DDNSResultObject(int cleanInterval) {
		mNode = null;
		mDone = false;
		mLifetime = cleanInterval;
	}
	
	DDNSResultObject() {
		mNode = null;
		mDone = false;
		mLifetime = -1;
	}
	
	/**
	 * Returning a DDNSException
	 * @param e
	 * @return
	 */
	static JSONObject marshall(DDNSException e) {
		try {
			JSONObject result = e.marshall();
			result.put("resulttype", "ddnsexception");
			return result;
		} catch (JSONException ee) {
			Log.e(TAG, "Fatal error trying to create JSONObject from exception: " + ee.getMessage() +
					   "Original exception message: " + e.getMessage()
				 );
			return new JSONObject(); // can't do much else -- adding anything can throw a JSONException
		}
	}
	
	// normal result marshall routines are in DDNSServiceRPCSTub
	
	// Callee (DDNSService) side methods
	//------------------------------------------------------------------------------------
	//------------------------------------------------------------------------------------
	

	
	//------------------------------------------------------------------------------------
	//------------------------------------------------------------------------------------
	// Caller (DDNSResolver) side methods
	
	/**
	 * "Constructor" for caller (DDNSResolverService) side.  It gets a JSONObject off the wire
	 * and hands it to this routine.
	 * @param obj
	 * @throws DDNSException
	 * @throws JSONException
	 */
	static DDNSResultObject unmarshall(JSONObject obj) throws JSONException, DDNSException {
		try {
			String type = obj.getString("resulttype");
			if ( type.equals("ddnsexception") )    DDNSException.unmarshall(obj);  // throws exception
			if ( type.equals("resolveresult") )    return DDNSServiceResolveStub.unmarshall(obj);
			if ( type.equals("registerresult") )   return DDNSServiceRegisterStub.unmarshall(obj);
			if ( type.equals("unregisterresult") ) return DDNSServiceUnregisterStub.unmarshall(obj);
			throw new DDNSException("Malformed response: don't recognize resulttype: " + obj.toString());

		} catch (JSONException e) {
			throw new DDNSRuntimeException("Response not parsable as DDNS response: " + obj.toString());
		}
	}
	
	// Caller (DDNSResolver) side methods
	//------------------------------------------------------------------------------------
	//------------------------------------------------------------------------------------
}
