package edu.uw.cs.cse461.sp12.OS;

import java.io.FileInputStream;
import java.util.HashMap;
import java.util.Properties;

import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.CommandLineParser;
import org.apache.commons.cli.HelpFormatter;
import org.apache.commons.cli.Options;
import org.apache.commons.cli.PosixParser;
import org.json.JSONException;
import org.json.JSONObject;

import edu.uw.cs.cse461.sp12.OS.DDNSResolverService.FullName;
import edu.uw.cs.cse461.sp12.OS.HTTPDService.HTTPProvider;
import edu.uw.cs.cse461.sp12.OS.NameManagerBase.NameException;
import edu.uw.cs.cse461.sp12.OS.RRecord.ARecord;
import edu.uw.cs.cse461.sp12.OS.RRecord.RRType;
import edu.uw.cs.cse461.sp12.util.Log;

/**
 * Protocol: Based on RPC.  The calls:
 * <p>
 * Request:  method: "register" 
 *           args: 
 * <br>Response:  void
 * <p>
 * Fetch all records (for all apps) for a specific host.
 * Request:  method: "fetchall"
 *           args:  {host: hostname}
 * <br>Response:  [ [appname, port, authoritative], ...]
 *
 * <pre>
 * app:"ddns" supports RPC calls:
 *     register( {host: hostname,  ip: ipaddr,   port: portnum} ) => { status: "OK" } or errormsg
 *     resolve( { host: hostname } ) => { host: repeats hostname, ip: ip address, authoritative: boolean } ) or errormsg
 * </pre>
 * 
 *  * @author zahorjan
 *
 */
public class DDNSService implements OSLoadable, HTTPProvider {
	private static String TAG="DDNSService";
	
	private DDNSNode mRoot;  // root of name tree
	private FullName mSoaName; // root name of my zone
	
	private HashMap<FullName, String> mPasswordMap;  // host name -> password
	
	private RPCCallableMethod<DDNSService> register;
	private RPCCallableMethod<DDNSService> resolve;
	

	@Override
	public String loadablename() {
		return "ddns";
	}
	
	/**
	 * Called to end execution.  Specifically, need to terminate any threads we've created.
	 */
	@Override
	public void shutdown() {
	}
	
	public String httpServe(String[] uriArray) {
		return toString();
	}
	//------------------------------------------------------------------------
	// Utility classes

	public static class DDNSException extends Exception {
		private static final long serialVersionUID = 1L;
		public DDNSException(String msg) { super(msg); }
	}

	//------------------------------------------------------------------------

	/**
	 * Constructor.  Registers the system RPCServerSocket with the parent as
	 * this host's ip address.  Registers the root server and itself in the
	 * local name cache.
	 * @throws DDNSException
	 */
	DDNSService() throws DDNSException {
		
		try {
			mRoot = null;

			//--------------------------------------------------------------
			// create name tree
			//    Example: ddns.soa = jz.cse461.:passwordWithParent
			//--------------------------------------------------------------

			RPCService rpcService = (RPCService)OS.getService("rpc");
			String myIP = rpcService.localIP();
			int myPort = rpcService.localPort();
			Log.d(TAG, "myAddress = " + myIP + ":" + myPort);

			String soaStr = OS.config().getProperty("ddns.soa");
			if ( soaStr == null ) throw new DDNSException("No ddns.soa entry in config file");
			String[] token = soaStr.split(":");
			if ( token.length != 2 ) throw new DDNSException("Invalid ddns.soa entry: " + soaStr);
			
			// this node must be added first to tree, to establish it as root
			mSoaName = new FullName(token[0]);
			addNode( new DDNSNode( mSoaName, new ARecord(myIP, myPort) ) );
			
			//--------------------------------------------------------------
			// set up RPC callable methods
			//--------------------------------------------------------------

			// export methods via the rpc service
			register = new RPCCallableMethod<DDNSService>(this, "_register");
			resolve = new RPCCallableMethod<DDNSService>(this, "_resolve");

			rpcService.registerHandler(loadablename(), "register", register );
			rpcService.registerHandler(loadablename(), "resolve", resolve );
			
			Log.wtf(TAG, "Starting ddns service for zone '" + this.mSoaName + "' on host '" + OS.hostname() + "' on port " + myPort);

			//--------------------------------------------------------------
			// the following aren't done on the root.  (If I'm root, I just registered myself...)
			//--------------------------------------------------------------
			
			if ( mSoaName.toString().isEmpty() ) return;

			//--------------------------------------------------------------
			// register root host
			//--------------------------------------------------------------

			FullName rootFullName = new FullName("");
			
			String rootHost = OS.config().getProperty("ddns.rootserver");
			if ( rootHost == null ) throw new DDNSException("DDNSAgent.DDNSAgent: no rootserver in config file");
			String rootPortStr = OS.config().getProperty("ddns.rootport");
			int rootPort;
			try {
				rootPort = Integer.parseInt(rootPortStr);
			} catch (Exception e) {
				throw new DDNSException("Invalid or missing ddns.rootport entry in config file");
			}
			DDNSNode rootNode = new DDNSNode(new FullName(""), new ARecord(rootHost, rootPort) );

		} catch (Exception e) {
			String msg = "Constructor caught exception: " + e.getMessage();
			Log.e(TAG, msg);
			throw new DDNSException(msg);
		}
	}
	
	//---------------------------------------------------------------------------------------------------------------------------
	// name tree manipulation
	
	private DDNSNode addNode(DDNSNode node) throws DDNSException {
		if ( mRoot == null ) {
			mRoot = node;
			return mRoot;
		}
		
		DDNSNode attachNode = _findLast(node.name());
		if ( attachNode.name().equals(node.name()) ) throw new DDNSException("addNode: Node " + node.name() + " already exists");
		String name = node.name().toString();
		name = name.substring(0, name.length()-attachNode.name().toString().length()-1);
		if ( name.indexOf('.') >= 0 ) throw new DDNSException("addNode: Can't add node " + node.name() + " to " + attachNode.name() );
		return node;
	}
	
	private DDNSNode _find(FullName name) throws DDNSException {
		DDNSNode result = _findLast(name);
		if ( !result.name().equals(name) ) return null;
		return result;
	}

	/**
	 * Resolve name as far as possible, and return node you end up on.
	 * @param name
	 * @return
	 */
	private DDNSNode _findLast(FullName fullname) throws DDNSException {
		String name = fullname.toString();
		String suffix = mRoot.name().toString();
		if ( !name.endsWith(suffix) ) throw new DDNSException("Node " + name + " isn't in this zone [" + suffix + "]");
		
		name = name.substring(0, name.length() - suffix.length() );
		String[] token = name.split("\\.");
		int index;
		DDNSNode attachNode = mRoot;
		DDNSNode nextNode;
		for ( index = token.length-1; index >= 0; attachNode = nextNode, index-- ) {
			nextNode = attachNode.child(new FullName(token[index] + "." + attachNode.name()));
			if ( nextNode == null ) break;
		}
		return attachNode;
	}
	
	
	//---------------------------------------------------------------------------
	// RPC callable routines
	
	private boolean _checkAuth(FullName host, String password) {
		if ( host==null || password==null ) return false;
		if ( !password.equals(mPasswordMap.get(host))) return false;
		return true;
	}

	/**
	*     register( {host: hostname, password: password, ip: ipaddr,  port: portnum} ) => { status: "OK" } or errormsg
	* 
	* @param args
	* @return
	*/
	public JSONObject _register(JSONObject args) throws JSONException, DDNSException {
		Log.i(TAG, "_register(" + args + ")");
		
		// only fullnames go in the db
		FullName newHost = new FullName(args.getString("host"));
		
		// register calls require a password
		if ( !_checkAuth(newHost, args.getString("password")))
			throw new DDNSException("Bad password for register call");
		
		DDNSNode node = _find(newHost);
		if ( node == null ) throw new DDNSException("No such name: " + newHost);
		
		String ip = args.getString("ip");
		int port = args.getInt("port");
		Log.e(TAG, "ip = " + ip + "  port = " + port);
		node.setRecord( new ARecord(ip, port) );

		return null;
	}
	
	
	/**
	 * Indicates host is going offline.
	 *      unregister( {host: hostname, password: password, ip: ipaddr,  port: portnum} ) => { status: "OK" } or errormsg
	 * @param args
	 * @return
	 * @throws JSONException
	 * @throws DDNSException
	 */
	public JSONObject _unregister(JSONObject args) throws JSONException, DDNSException {

		FullName host = new FullName(args.getString("host"));
		
		// unregister calls require a password
		if ( !_checkAuth(host, args.getString("password")))
			throw new DDNSException("Bad password for unregister call");

		//TODO: implement
		return null;
	}

	/**
	 * This version is invoked via RPC.  It's simply a wrapper that extracts the call arguments
	 * and invokes resolve(host).
	 * @param callArgs
	 * @return
	 */
	public JSONObject _resolve(JSONObject args) throws JSONException, DDNSException {
		Log.i(TAG, "_resolve(" + args + ")");
		JSONObject result = new JSONObject();
		
		// resolve calls don't require passwords

		String hostStr = args.getString("host");
		if ( hostStr == null ) throw new JSONException("Malformed call arguments: '" + args.toString() + "'");

		FullName host = new FullName(hostStr);
		ARecord address = (ARecord)resolve(host); // throws exception if we get a record that isn't an ARecord?
		if ( address == null ) throw new DDNSException("Can't resolve host '" + host + "'");
		//TODO: negative entry?
		result.put("host", host).put("ip", address.ip()).put("port", address.port()).put("auth", address.authoritative());

		return result;
	}
	
	// RPC callable routines
	//---------------------------------------------------------------------------

	//---------------------------------------------------------------------------
	// resolve routines
	/**
	 * If no desired record type is given, assume caller wants an ARecord.  Find and return that.
	 */
	public ARecord resolve(FullName host) {
		Log.d(TAG, "Resolve(" + host + ")");
		return resolve(host, RRType.RRTYPE_A);
	}
	
	/**
	 * Resolves a host name to its resource record.  If the record associated with the name isn't the desired type,
	 * and exception is thrown.
	 * @param host The host name (e.g., "jz.cse461")
	 * @param type The desired RRType of the record.
	 * @return The RRecord of type type, if it exists.  Otherwise, and exception is thrown.
	 */
	public ARecord resolve(FullName host, RRType type) {
		Log.d(TAG, "resolve(" + host + ", " + type + ")");
		ARecord address = new ARecord(host + ":" + type);
		
		// only fullnames go in the db
		FullName fullhost = new FullName(host);

		//Log.e("***resolve(" + host + ", " + app + ")");

		// first try a cached address, if there is one
		if ( _resolveFromCache(fullhost, type, address)) return address;

		// cache updating may have encountered a stale, cached record for some non-root ancestor.
		// Try resolution from root
		if ( _fullResolve(fullhost, type, address) && _resolveFromCache(fullhost, type, address) ) return address;

		// cache negative info
		try {
			if ( address.ip == null ) manager.write(fullhost, RRType.RRTYPE_A.toString(), null, false);
			if ( address.port == null ) manager.write(fullhost, type.toString(), null, false);
			// try to get the negative record
			_resolveFromCache(fullhost, type, address);
		} catch (NameException e ) {
			// fatal error -- can't install new record(s)
		}

		return address;
	}
	
	/**
	 * This is a last resort resolver.  It starts at the root and works its way down.
	 *
	 * @param host
	 * @param type
	 * @param address
	 * @return
	 */
	private ARecord _fullResolve(FullName host) {
		Log.d(TAG, "_fullResolve(" + host + ")");
		String delims = "[\\.]";
		String[] component = host.toString().split(delims);

		try {
			// start at the root zone
			FullName currentZoneName = new FullName("");
			DDNSNode currentZoneNode = _resolveFromCache(currentZoneName);
			if ( currentZoneNode == null ) throw new DDNSException("Couldn't fetch root server address from cache");
			ARecord currentZoneAddr = currentZoneNode.getARecord();
			
			while ( ??? ) {
				RPCCallerSocket socket = new RPCCallerSocket(currentZoneNode.name().toString(),
															 currentZoneAddr.ip(),
															 Integer.toString(currentZoneAddr.port())
															);
				JSONObject resolution = socket.invoke(loadablename(), "resolve", new JSONObject().put("host", host.toString());
				DDNSNode receivedNode = new DDNSNode(resolution);
				// if we got an A record, we're done
				ARecord addressRecord = receivedNode.getARecord();
				if ( addressRecord != null ) return addressRecord;
				// otherwise, if we got an NS record, follow it
				RRecord.NSRecord nsRecord = receivedNode.getNSRecord();
				if ( nsRecord == null ) return null;
				
				currentZoneName = DDNSNode.name();
			}


			// skip the root.  (host is a fullname.)
			for ( int i=component.length-2; i>=0; i++ ) {
				name = new FullName(component[i] + '.' + name);
				Log.e(TAG, "_fullResolve: working on '" + name + "'");
				address = resolve(manager, name.toString(), RRType.RRTYPE_RPC);
				if ( address.type != RRType.RRTYPE_RPC ) return false;
				if ( !address.mAuthoritative ) throw new DDNSException("Encountered non-authoritative record for name '" + name + "'");
				manager.write(name, RRType.RRTYPE_A.toString(), address.ip, address.mAuthoritative);
				manager.write(name, RRType.RRTYPE_RPC.toString(), address.port, address.mAuthoritative);
			}
			return true;
		} catch (Exception e) {
			Log.e(TAG, "_fullResolve caught exception: " + e.getMessage());
		}
		return false;
	}

	// resolve routines
	//---------------------------------------------------------------------------
	
	//---------------------------------------------------------------------------
	// register routines
	
	/**
	 * Update address mapping.  The interface allows only a host specification.
	 * The port given is implicitly for the RPC service on that host.
	 * 
	 * @param fullhost The name of the host for this mapping.
	 * @param ip  That host's IP address.
	 * @param port The port of the RPC service on that host.
	 */
	private void _register(FullName fullhost, String ip, String port) {
		Log.d(TAG, "_register(" + fullhost + ", " + ip + ", " + port + ")");
		NameManager manager = null;
		try {
			FullName myHost = new FullName(OS.hostname());
			// Only the entries for this host and for the root are authoritative - others
			// can change, and must be purged from the cache periodically.
			boolean auth = (fullhost.toString().isEmpty() || fullhost.equals(myHost));
			manager = new NameManager();
			manager.write(fullhost, RRType.RRTYPE_A.toString(), ip, auth);
			manager.write(fullhost, RRType.RRTYPE_RPC.toString(), port, auth);
			Log.d(TAG, manager.toString());
		} catch (Exception e) {
			Log.e(TAG, "_register caught exception " + e.getMessage());
		} finally {
			if ( manager != null ) manager.discard();
		}
	}
	
	
	/**
	 * Given an argument name like "www" and soa name <soaname>, registers a node for
	 * name www.<soaname>
	 * @param name
	 */
	public void registerRelative(String name, String ip, String port) {
		_register( new FullName(name + '.' + mSoaName), ip, port );
	}
	// register routines
	//---------------------------------------------------------------------------
	
		
	/**
	 * The usual toString.
	 */
	public String toString() {
		StringBuilder sb = new StringBuilder();
		String currentName = OS.hostname();
		sb.append("Hostname: ");
		if ( currentName != null ) sb.append(currentName).append("\n");
		else sb.append("undefined\n");
		
		NameManager manager = null;
		try {
			manager = new NameManager();
			sb.append(manager.toString()).append("\n");
		} catch (Exception e) {
			sb.append("DDNSAgent.toString: caught exception: " + e.getMessage());
		} finally {
			if (manager != null) manager.discard();
		}
		return sb.toString();
	}

	/**
	 * A simple test driver that ends up dumping the current cached naming information.
	 * @param args
	 */
	public static void main(String[] args) {
		final String TAG="DDNSAgent.main";
		String configFilename = "config.ini";
		try {
			// This code deals with command line options
			Options options = new Options();
			options.addOption("f", "configfile", true, "Config file name (Default: " + configFilename + ")");
			options.addOption("h", "help", false, "Print this message");

			CommandLineParser parser = new PosixParser();

			CommandLine line = parser.parse(options, args);
			if ( line.hasOption("help") ) {
				HelpFormatter formatter = new HelpFormatter();
				formatter.printHelp(DDNSService.class.getName(), options );
				return;
			}
			if ( line.hasOption("configfile") ) configFilename = line.getOptionValue("configfile");

			OS.boot(configFilename);

			DDNSService agent = (DDNSService)OS.getService("ddns");
			Log.e(TAG, agent.toString());

			// Resolve a host
			RRecord testAddress = agent.resolve(OS.hostname(), RRType.RRTYPE_A);
			Log.e(TAG, testAddress.toString());

			testAddress = agent.resolve(OS.hostname());
			Log.e(TAG, testAddress.toString());
			
			testAddress = agent.resolve("");
			Log.e(TAG, testAddress.toString());

			testAddress = agent.resolve(new FullName(OS.hostname()).parent().toString());
			Log.e(TAG, testAddress.toString());

			testAddress = agent.resolve("foo.jz.cse461");
			Log.e(TAG, testAddress.toString());

			testAddress = agent.resolve("foo.cse461");
			Log.e(TAG, testAddress.toString());

		} catch (Exception e) {
			Log.e(TAG, "DDNSAgent caught exception: " + e.getMessage());
		}
	}
}
