package edu.uw.cs.cse461.sp12.OS;

import java.util.HashMap;
import java.util.Set;
import java.util.Timer;
import java.util.TimerTask;

import edu.uw.cs.cse461.sp12.OS.DDNSNameStructure.DDNSNode;
import edu.uw.cs.cse461.sp12.OS.RRecord.ARecord;
import edu.uw.cs.cse461.sp12.util.Log;

public class DDNSResolverService extends RPCCallable {
	private static String TAG="DDNSResolverService";

	private Timer mTimer;  // to periodically register with parent
	private long mCacheTTL;
	
	private HashMap<FullName, DDNSNode> mCache;
	private DDNSServiceHTTPD mHTTPDServer;
	
	private RPCCallableMethod<DDNSResolverService> resolve;
	
	@Override
	public String servicename() {
		return "ddnsresolver";
	}
	
	/**
	 * Try to keep straight when we have a fully qualified name, and when we may not,
	 * using the compiler's type checking system.
	 * <p>
	 * Except for the root, a FullName is an absolute name ending with a '.'.
	 * The name of the root is the empty string, "".
	 * <p>
	 * Example: FullName("a.b.c") is "a.b.c.".
	 * <br>Example: FullName("a.b.c.") is "a.b.c.".
	 * <br>Example: FullName(".a.b.c.") is "a.b.c.".
	 * <br>Example: FullName(".") is "".
	 * @author zahorjan
	 *
	 */
	public static class FullName {
		private static final String TAG="FullName";
		public static final char NAMESEP = '.';
		private String delegate;
		/**
		 * Deals with optional trailing '.', by applying one if needed.  The root name, "", never has a dot.
		 * All other names are of form "a.b.c.".
		 * @param name
		 * @return
		 */
		public FullName(String name) {
			delegate = name;
			if ( delegate == null ) delegate = "";
			else if ( delegate.isEmpty() || delegate.equals(".")) delegate = "";
			else {
				if ( delegate.startsWith(".") ) delegate = delegate.substring(1);
				if ( !delegate.endsWith(".") ) delegate = delegate + ".";
			}
		}
		/**
		 * Given a valid name, returns parent of that name.  For example, given a.b.c.d, returns b.c.d.
		 * (Note that the name of the root is "").
		 * @param name  The name whose parent you want
		 * @return The name of the parent.  Returns the root ("") if argument name is null.
		 */
		public FullName parent() {
			if ( delegate == null ) return null;
			int index = delegate.indexOf(NAMESEP);
			if ( index < 0 || index >= delegate.length()-1  ) return new FullName("");
			return new FullName(delegate.substring(index+1));
		}
		
		/**
		 * Indicates whether or not this FullName is an immediate child of the parent.
		 * For example, a.b.c. is a child of b.c., but not of c.
		 * @param parent Suspected parent's name
		 * @return true if a direct child, false otherwise
		 */
		public boolean isChildOf(FullName parent) {
			if (delegate.length() < parent.toString().length()+2 ) return false;
			if ( !delegate.endsWith(parent.toString()) ) return false;
			String child = delegate.substring(0, delegate.length()-parent.toString().length());
			if ( !child.endsWith(".") || child.equals(".") ) return false;
			child = child.substring(0,child.length()-1);
			if ( child.indexOf('.') >= 0 ) return false; // it's an ancestor, but not a child
			return true;
		}
		
		/**
		 * Required to use a FullName as a Hash key (?)
		 * @param other
		 * @return
		 */
		public Boolean equals(FullName other) {
			return delegate != null && delegate.equals(other);
		}
		
		/**
		 * Required to use a FullName as a Hash key (?)
		 */
		public int hashCode() {
			return delegate.hashCode();
		}
		
		public String toString() {
			return delegate;
		}
	}
	
	/**
	 * Called to end execution.  Specifically, need to terminate any threads we've created.
	 */
	@Override
	public void shutdown() {
		if ( mTimer != null ) mTimer.cancel();
		mTimer = null;
		if ( mHTTPDServer != null ) mHTTPDServer.stop();
		mHTTPDServer = null;
	}
		
	public DDNSResolverService() {
		mCache = new HashMap<FullName, DDNSNode>();
		mTimer = new Timer();

		//--------------------------------------------------------------
		// start up cache cleaning thread
		//--------------------------------------------------------------

		String ttlStr = OS.config().getProperty("resolver.cachettl");
		try {
			mCacheTTL = Integer.parseInt(ttlStr);
			if ( mCacheTTL < 60 ){
				Log.w(TAG, "Minimum cache ttl is 60 seconds.  Resetting value from config file.");
				mCacheTTL = 60;
			}
		} catch (Exception e) {
			Log.e(TAG, "ADVISORY: Invalid or missing ddns.cachettl property in config file");
			mCacheTTL = 60;  // default is 1 minutes
		}
		mTimer.scheduleAtFixedRate( new TimerTask() {
											public void run() {
												Log.w(TAG, "Resolver cleaning cache");
												try {
													Set<FullName> keySet = mCache.keySet();
													for ( FullName name : keySet ) {
														DDNSNode node = mCache.get(name);
														if ( node.record()!=null && node.record().ttl() < OS.now() ) {
															mCache.remove(name);
															Log.w(TAG, "\tRemoved cached node for " + name);
														}
													}
												} catch (Exception e) {
													Log.e(TAG, "Couldn't clean cache");
												}
											}
			                        }, 
			                        1000 * mCacheTTL,
			                        1000 * mCacheTTL
								  );

	}

	DDNSNode addNode(DDNSNode node) {
		mCache.put(node.name(), node);
		return node;
	}
	
	/**
	 * Try to fetch ARecord info for name from the cache.
	 *
	 * @param host
	 * @return  ARecord for host, if one in the cache, null otherwise
	 */
	public RRecord.ARecord resolve(FullName host) {
		Log.d(TAG, "resolve(" + host + ")");

		try {
			// fetch host record
			DDNSNode node = mNameStructure.cache().get(host);
			if ( node == null ) return null;  // not in cache
			return (ARecord)node.getARecord();
		} catch (Exception e ) {
			// no cached value
			Log.e(TAG, "ADVISORY: _tryResolve caught exception: " + e.getMessage());
			return null;
		}
	}
	

}
