package edu.uw.cs.cse461.SNet;

import java.io.File;
import java.util.Collections;
import java.util.Iterator;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import edu.uw.cs.cse461.DB461.DB461.DB461Exception;
import edu.uw.cs.cse461.DB461.DB461.RecordSet;
import edu.uw.cs.cse461.NetBase.NetBase;
import edu.uw.cs.cse461.OS.DDNS.DDNSException;
import edu.uw.cs.cse461.OS.DDNS.DDNSFullName;
import edu.uw.cs.cse461.OS.DDNS.DDNSResolverService;
import edu.uw.cs.cse461.OS.DDNS.DDNSRRecord.ARecord;
import edu.uw.cs.cse461.OS.RPC.RPCCallerSocket;
import edu.uw.cs.cse461.OS.RPC.RPCService;
import edu.uw.cs.cse461.SNetDB.SNetDB461;
import edu.uw.cs.cse461.SNetDB.SNetDB461.CommunityRecord;
import edu.uw.cs.cse461.SNetDB.SNetDB461.Photo;
import edu.uw.cs.cse461.SNetDB.SNetDB461.PhotoRecord;
import edu.uw.cs.cse461.util.Base64;
import edu.uw.cs.cse461.util.Log;

/**
 * Handles UI-independent operations on SNetDB
 * 
 * @author zahorjan
 *
 */
public class SNetController {
	private static final String TAG="SNetController";
	
	public enum PhotoType { MY_PHOTO, CHOSEN_PHOTO };
	
	private String mDBName;
	
	public SNetController(String dbDirName) {
		mDBName = dbDirName + "/" + new DDNSFullName(NetBase.theOS().hostname()) + "snet.db";
	}
	
	public String DBName() {
		return mDBName;
	}
	
	private static boolean _needPhoto(SNetDB461 db, int hash) throws DB461Exception {
		PhotoRecord r = db.PHOTOTABLE.readOne(hash);
		return r == null || r.file == null;
	}

	/**
	 * The caller side of fetchUpdates.
	 * @param friend
	 * @return
	 * @throws DB461Exception
	 */
	synchronized public boolean fetchUpdates( String friend, File galleryDir) throws DB461Exception {
		SNetDB461 db = null;
		JSONObject reply = null;
		try {
			DDNSResolverService resolver = (DDNSResolverService)NetBase.theOS().getService("ddnsresolver");
			ARecord address = null;
			try {
				address = resolver.resolve(friend);
			} catch (DDNSException e) {
				Log.e(TAG, "DDNSException: " + e.getMessage());
				throw e;
			}
			
			db = new SNetDB461(mDBName);
			
			// send contact message containing:
			//    Our full friend table, minus the isFriend field
			//    A list of photos we'd like to get copies of:
			//       These are photos for our friends that we're missing, not just all photos we're missing

			JSONObject communityMap = new JSONObject();
			JSONArray needPhotoArray = new JSONArray();
			
			RecordSet<CommunityRecord> friendVec = db.COMMUNITYTABLE.readAll();
			for ( CommunityRecord r : friendVec ) {
				communityMap.put( r.name.toString(), new JSONObject().put("generation", r.generation)
																	 .put("myphotohash", r.myPhotoHash)
																	 .put("chosenphotohash", r.chosenPhotoHash)
						        );
			}
			
			RecordSet<PhotoRecord> photoVec = db.PHOTOTABLE.readAll();
			for ( PhotoRecord r : photoVec ) {
				if ( r.file == null ) {
					needPhotoArray.put(r.hash);
				}
			}
			
			JSONObject args = new JSONObject().put("community", communityMap)
					  						  .put("needphotos", needPhotoArray);

			// Reply contains
			//    A list of friends with gen numbers greater than ours
			//    A list of photos that we requested
			
			// Watch out -- logging a photo causes Android to run out of memory...
			Log.d(TAG, "Call args = " + args.toString());
			RPCCallerSocket sock = new RPCCallerSocket(friend, address.ip(), address.port());
			reply = sock.invoke("snet", "fetchUpdates", args);
			Log.d(TAG,"Reply = " + reply.toString());
//			sock.close();
			
			// do friend updates
			if ( reply.has("communityupdates")) {
				JSONObject friendUpdateMap = reply.getJSONObject("communityupdates");
				for ( Iterator<String> it = friendUpdateMap.keys(); it.hasNext(); ) {
					CommunityRecord newRecord = db.COMMUNITYTABLE.createRecord();
					JSONObject member = null;
					try {
						String recName = it.next();
						if ( recName == null ) continue;
						newRecord.name = new DDNSFullName(recName);
						member = friendUpdateMap.getJSONObject(newRecord.name.toString());
						newRecord.generation = member.getInt("generation");
						newRecord.myPhotoHash = member.getInt("myphotohash");
						newRecord.chosenPhotoHash = member.getInt("chosenphotohash");
					} catch (JSONException e) {
						Log.e(TAG, "Likely bad reply value in communityupdates: name = " + newRecord.name );
						if ( member != null ) Log.e(TAG, member.toString());
						continue;
					}
					
					CommunityRecord r = db.COMMUNITYTABLE.readOne(newRecord.name.toString());
					if ( r == null ) {
						incrementPhotoRefCount(db, newRecord.myPhotoHash);
						incrementPhotoRefCount(db, newRecord.chosenPhotoHash);
						db.COMMUNITYTABLE.write(newRecord);
						continue;
					}
					
					if ( r.generation > newRecord.generation ) {
						Log.w(TAG,  "Got community update but am already at generation " + r.generation + " for that member: " + newRecord);
						continue;
					}
					// Have a newer generation to replace an existing entry
					// Must increment before decrementing to avoid passing through 0 and causing file to be deleted.
					incrementPhotoRefCount(db, newRecord.myPhotoHash);
					incrementPhotoRefCount(db, newRecord.chosenPhotoHash);
					decrementPhotoRefCount(db, r.myPhotoHash);
					decrementPhotoRefCount(db, r.chosenPhotoHash);
					db.COMMUNITYTABLE.write(newRecord);
				}
			}
			
			// do photo updates
			if ( reply.has("photoupdates")) {
				JSONArray photoUpdateArray = reply.getJSONArray("photoupdates");
				
				for ( int i=0; i<photoUpdateArray.length(); i++ ) {
					int hash = photoUpdateArray.getInt(i);
					
					if ( !_needPhoto(db, hash)) {
						Log.w(TAG, friend + " returned photo with hash " + hash + " but I have no photo record for that hash");
						continue;
					}
					
					// we arbitrarily pick .jpg for the extent -- hope it works...
					File newFile = new File(galleryDir, Integer.toString(hash) + ".jpg");
					if ( newFile.exists() ) {
						Log.e(TAG, "Seem to have requested and had returned file " + newFile.getAbsoluteFile() + " but it already exists");
						continue;
					}
					
					args = new JSONObject().put("photohash", hash);
					RPCCallerSocket photoSocket = new RPCCallerSocket(friend, address.ip(), address.port());
					JSONObject photoReply = photoSocket.invoke("snet", "fetchPhoto", args);
//					photoSocket.close();
					
					
					if (!photoReply.has("photohash")) throw new  Exception("malformed response to fetchPhoto: missing photohash");
					int replyHash = photoReply.getInt("photohash");
					if ( replyHash != hash ) throw new Exception("bad response: reply hash (" + replyHash + ") doesn't match requested hash (" + hash + ")");
					
					if (!photoReply.has("photodata")) throw new  Exception("malformed response to fetchPhoto: missing photodata");
					Base64.decodeToFile(photoReply.getString("photodata"), newFile.getAbsolutePath());
					// verify hash value
					Photo photo = new Photo(newFile);
					if ( photo.hash() != hash ) {
						Log.e(TAG, friend + " returned photo data with hash " + hash + " but I get " + photo.hash() + " for the hash");
						newFile.delete();
						continue;
					}
					
					PhotoRecord r = db.PHOTOTABLE.readOne(hash);
					r.file = newFile;
					db.PHOTOTABLE.write(r);
					Log.w(TAG,  "Updated photo record: " + r);
				}
			}
			

			// Other end may then contact us, if it looks like we might have something they're interested in
			
		} catch (JSONException e) {
			throw new DB461Exception("Likely malformed fetchUpdates response: " + (reply != null?reply.toString():"") + "\n" + e.getMessage());
		} catch (Exception e) {
			e.printStackTrace();
			throw new DB461Exception("fetchUpdates caught exception: "+ e.getMessage());
		}
		finally {
			if ( db != null ) db.discard();
		}
		return false;
	}
	
	/**
	 * The callee side of fetchUpdates.
	 * @param args
	 * @return
	 */
	synchronized public JSONObject _fetchUpdates(JSONObject args) throws Exception {
		JSONObject result = new JSONObject();
		SNetDB461 db = null;
		try {
			db = new SNetDB461(mDBName);
			RecordSet<CommunityRecord> friendVec = db.COMMUNITYTABLE.readAll();
			
			JSONObject otherMemberMap = args.getJSONObject("community");
			if ( otherMemberMap == null ) throw new Exception("Malformed call args: no community object: " + args.toString());
			JSONArray needPhotoArray = args.getJSONArray("needphotos");
			if ( needPhotoArray == null ) throw new Exception("Malformed call args: no needphotos array: " + args.toString());
			
			// Do I have friend entries that are more up to date than caller?
			JSONObject memberUpdates = new JSONObject();
			for ( CommunityRecord myRecord : friendVec ) {
				try {
					if ( otherMemberMap.has(myRecord.name.toString()) ) {
						int otherGen = otherMemberMap.getJSONObject(myRecord.name.toString()).getInt("generation");
						if ( otherGen >= myRecord.generation ) continue;
					}
					memberUpdates.put(myRecord.name.toString(), new JSONObject().put("generation", myRecord.generation)
															  					.put("myphotohash", myRecord.myPhotoHash)
															  					.put("chosenphotohash", myRecord.chosenPhotoHash)
							         );
					Log.w(TAG, "Returning friend '"  + myRecord.name + "'");
				} catch (JSONException e) {}
			}
			result.put("communityupdates", memberUpdates);
			
			// Does caller know about community members that I don't know about,
			// or have more up to date information?
			Iterator<String> it = otherMemberMap.keys();
			while ( it.hasNext()) {
				DDNSFullName name = new DDNSFullName(it.next());
				CommunityRecord myRecord = db.COMMUNITYTABLE.readOne(name.toString());
				JSONObject otherRecord = otherMemberMap.getJSONObject(name.toString()); 
				if ( myRecord == null || otherRecord.getInt("generation") > myRecord.generation ) {
					CommunityRecord newRecord = db.createCommunityRecord();
					newRecord.name = name;
					newRecord.generation = otherRecord.getInt("generation");
					newRecord.myPhotoHash = otherRecord.getInt("myphotohash");
					newRecord.chosenPhotoHash = otherRecord.getInt("chosenphotohash");
					db.COMMUNITYTABLE.write(newRecord);
					incrementPhotoRefCount(db, newRecord.myPhotoHash);
					incrementPhotoRefCount(db, newRecord.chosenPhotoHash);
					if ( myRecord == null ) Log.e(TAG, "Discovered member '"  + newRecord.name + "'");
					else {
						decrementPhotoRefCount(db, myRecord.myPhotoHash);
						decrementPhotoRefCount(db, myRecord.chosenPhotoHash);
						Log.d(TAG,  "Updated record: " + newRecord);
					}
				}
			}
			
			// Do I have any photos the caller wants?
			JSONArray photoUpdates = new JSONArray();
			for ( int i=0; i<needPhotoArray.length(); i++ ) {
				int hash = needPhotoArray.getInt(i);
				try {
					PhotoRecord r = db.PHOTOTABLE.readOne(hash);
					if ( r != null && r.file != null && r.file.exists() ) photoUpdates.put( hash );
				} catch (Exception e) {}
			}
			result.put("photoupdates", photoUpdates);
			// we run out of memory if we try to log photos
			if ( photoUpdates.length() == 0 ) Log.w(TAG, "Returning: " + result.toString() );
			else Log.i(TAG, "Returning " + photoUpdates.length() + " photos");
			return result;
		}
		finally {
			if ( db != null ) db.discard();
		}
	}
	
	/**
	 * Callee side of fetchPhoto (fetch one photo)
	 * @param args
	 * @return
	 * @throws Exception
	 */
	synchronized public JSONObject _fetchPhoto(JSONObject args) throws Exception {
		JSONObject result = new JSONObject();
		SNetDB461 db = null;

		try {

			db = new SNetDB461(mDBName);

			int hash = args.getInt("photohash");
			Log.w(TAG, "_fetchPhoto(" + hash + ") called");
			result.put("photohash", hash);

			PhotoRecord photoRec = db.PHOTOTABLE.readOne(hash);
			if ( photoRec == null || photoRec.file == null || !photoRec.file.exists() ) throw new Exception("Caller requested photo " + hash + " but I don't have it.");

			Log.w(TAG, "_fetchPhoto(" + hash + "): returning photo");
			result.put( "photodata", Base64.encodeFromFile(photoRec.file.getAbsolutePath()) );
			return result;
		}
		finally {
			if ( db != null ) db.discard();
		}
	}	
	
	/**
	 * Makes sure that the photo file (a) is in the gallery, and (b) is named hhhh.jpg, where hhhh is
	 * the hash of the contents.
	 * @param filename
	 * @param galleryDir
	 * @return
	 * @throws DB461Exception
	 */
	synchronized public Photo normalizeFile(String filename, File galleryDir) throws DB461Exception {
		try {
			Photo photo = new Photo(new File(filename));
			String newName = galleryDir.getAbsolutePath() + "/" + photo.hash() + ".jpg";
			if ( !photo.file().getAbsolutePath().equals(newName) ) {
				Log.e(TAG, "Renaming file "+ photo.file().getAbsolutePath() + "\nto " + newName);
				File newFile = new File(newName);
				photo.file().renameTo(newFile);
				photo = new Photo( photo.hash(), newFile);
				Log.e(TAG, "photo file's name: " + photo.file().getAbsolutePath());
			}
			return photo;
		} catch (Exception e) {
			String msg = "normalizeFile caught exception: " + e.getMessage(); 
			Log.e(TAG, msg);
			throw new DB461Exception(msg);
		}
	}
	
	/**
	 * Register a new chosen photo.
	 * @param myName
	 * @param filename
	 * @return
	 * @throws DB461Exception
	 */
	synchronized public void newChosenPhoto(DDNSFullName myName, String filename, File galleryDir) throws DB461Exception {
		SNetDB461 db = null;
		Photo photo = normalizeFile(filename, galleryDir);
		try {
			db = new SNetDB461(mDBName);
			
			// the member must already exist, as it's the user.
			// the photo must also already exist, as it's being chosen.
			
			incrementPhotoRefCount(db, photo.hash());  // have to increment before decrementing...
			
			CommunityRecord memberRecord = db.COMMUNITYTABLE.readOne(myName.toString());
			if ( memberRecord == null ) throw new DB461Exception("newChosenPhoto called but member doesn't exist in db? " + myName);
			
			decrementPhotoRefCount(db, memberRecord.chosenPhotoHash);
			memberRecord.chosenPhotoHash = photo.hash();
			memberRecord.generation++;
			db.COMMUNITYTABLE.write(memberRecord);
			
			// make sure photo record has filename component set
			PhotoRecord pRecord = db.PHOTOTABLE.readOne(photo.hash());
			pRecord.file = photo.file();
			db.PHOTOTABLE.write(pRecord);

		} catch (Exception e) {
			Log.e(TAG, "Caught exception: " + e.getMessage());
			throw new DB461Exception("contact caught exception: "+ e.getMessage());
		}
		finally {
			if ( db != null ) db.discard();
		}
	}
	
	synchronized public int setGenerationNumber(DDNSFullName myName, int gen) throws DB461Exception {
		SNetDB461 db = null;
		int oldGen = -1;
		try {
			db = new SNetDB461(mDBName);
			CommunityRecord member = db.COMMUNITYTABLE.readOne(myName.toString());
			if ( member == null ) throw new DB461Exception("setGenerationNumber called but member doesn't exist in db? " + myName);
			oldGen = member.generation;
			member.generation = gen;
			db.COMMUNITYTABLE.write(member);
			return oldGen;
		} catch (Exception e) {
			Log.e(TAG, "Caught exception: " + e.getMessage());
			throw new DB461Exception("setGenerationNumber caught exception: "+ e.getMessage());
		}
		finally {
			if ( db != null ) db.discard();
		}
	}
	
	synchronized public String getStatusMsg() {
		SNetDB461 db = null;
		StringBuilder sb = new StringBuilder();
		try {
			sb.append("Host: ").append(NetBase.theOS().hostname()).append("\n");
			RPCService rpcService = (RPCService)NetBase.theOS().getService("rpc");
			sb.append("Location: ").append(rpcService.localIP()).append(":").append(rpcService.localPort()).append("\n");
			db = new SNetDB461(mDBName);
			CommunityRecord member = db.COMMUNITYTABLE.readOne(new DDNSFullName(NetBase.theOS().hostname()).toString());
			sb.append(member.toString());
		} catch (Exception e) {
			Log.e(TAG, "getStatusMsg: caught exception: " + e.getMessage());
		}
		finally {
			if ( db != null ) db.discard();
		}
		return sb.toString();
	}
	
	synchronized public boolean newMyPhoto(DDNSFullName myName, String filename, File galleryDir) throws DB461Exception {
		SNetDB461 db = null;
		Photo photo = normalizeFile(filename, galleryDir);
		try {
			db = new SNetDB461(mDBName);
			
			// the member must exist, as it's the user
			// Android: no photo record exists, as the photo was just taken
			// Console: the photo might exist but under some different name
			
			incrementPhotoRefCount(db, photo.hash());
			
			CommunityRecord member = db.COMMUNITYTABLE.readOne(myName.toString());
			if ( member == null ) throw new DB461Exception("newMyPhoto called but member doesn't exist in db? " + myName);
			decrementPhotoRefCount(db, member.myPhotoHash);
			member.myPhotoHash = photo.hash();
			member.generation++;
			db.COMMUNITYTABLE.write(member);
			
			PhotoRecord photoRecord = db.PHOTOTABLE.readOne(photo.hash());
			photoRecord.file = photo.file();
			db.PHOTOTABLE.write(photoRecord);

		} catch (Exception e) {
			Log.e(TAG, "Caught exception: " + e.getMessage());
			throw new DB461Exception("newMyPhoto caught exception: "+ e.getMessage());
		}
		finally {
			if ( db != null ) db.discard();
		}
		return false;
	}
	
	/**
	 * Increments the reference count of a photo.  If the photo is not already in the DB,
	 * creates an entry for it, sets ref count to 1, and records its filename.
	 * @param hash Photo's hash value.  A value of 0 means there is no photo. (!!!)
	 * @return The incremented reference count
	 * @throws DB461Exception
	 */
	synchronized public int incrementPhotoRefCount(SNetDB461 db, int hash) throws DB461Exception {
		if ( hash == 0 ) return 0;
		PhotoRecord record = db.PHOTOTABLE.readOne(hash);
		if ( record == null ) {
			record = db.createPhotoRecord();
			record.hash = hash;
			record.refCount = 0;
		}
		record.refCount++;
		db.PHOTOTABLE.write(record);
		return record.refCount;
	}
	
	/**
	 * Decrements the reference count of a photo that is already in the DB.
	 * If the ref count goes to zero, deletes the photo from the DB.
	 * @param hash Photo's hash value
	 * @return The decremented reference count
	 * @throws DB461Exception
	 */
	synchronized public int decrementPhotoRefCount(SNetDB461 db, int hash) throws DB461Exception {
		if ( hash == 0 ) return 0;
		PhotoRecord record = db.PHOTOTABLE.readOne(hash);
		if ( record == null ) {
			// something's wrong with the db!  Try to forge ahead anyway.
			Log.e(TAG, "decrementPhotoRefCount(" + hash + "): No record found");
			return 0; // indicate the photo has been deleted
		}
		record.refCount--;
		if ( record.refCount > 0 ) db.PHOTOTABLE.write(record);
		else {
			db.PHOTOTABLE.delete(record.hash);
			if ( record.file != null ) record.file.delete();
		}
		return record.refCount;
	}
	
	/**
	 * Sets friend status of a member.
	 * @param friend
	 * @param isfriend true to make a friend; false to unfriend
	 */
	synchronized public void setFriend(DDNSFullName friend, boolean isfriend) throws DB461Exception {
		SNetDB461 db = null;
		try {
			db = new SNetDB461(mDBName);
			CommunityRecord r = db.COMMUNITYTABLE.readOne(friend.toString());
			if ( r == null ) throw new DB461Exception("addFriend: " + friend + " is not in the community table");
			if ( r.isFriend == isfriend ) return;  // a small optimization
			r.isFriend = isfriend;
			db.COMMUNITYTABLE.write(r);
		} catch (Exception e) {
			Log.e(TAG, "Caught exception: " + e.getMessage());
			throw new DB461Exception("contact caught exception: "+ e.getMessage());
		}
		finally {
			if ( db != null ) db.discard();
		}
	}

	/**
	 * Called only to make sure that the user is registered.
	 * @param user
	 */
	public void registerBaseUsers(DDNSFullName user) throws DB461Exception {
		SNetDB461 db = null;
		try {
			db = new SNetDB461(mDBName);
			db.registerMember( user );
			db.registerMember( new DDNSFullName("") );  // and the root
		} catch (Exception e) {
			Log.e(TAG, "registerUser caught exception: " + e.getMessage());
			throw new DB461Exception("registerUser caught exception: " + e.getMessage());
		}
		finally {
			if ( db != null ) db.discard();
		}
	}

	/**
	 * Called by SNet implementation.
	 * @param uriVec
	 * @return
	 */
	public String httpServe(String[] uriVec) throws DB461Exception {
		SNetDB461 db = null;
		try {
			db = new SNetDB461(mDBName);
			StringBuilder sb = new StringBuilder().append("<html><head></head><body>");
			
			sb.append("<table><tr><th>Name<th>Generation<th>My Photo<th>Chosen Photo</tr>\n");
			RecordSet<CommunityRecord> memberVec = db.COMMUNITYTABLE.readAll();
			Collections.sort(memberVec);
			for ( CommunityRecord r : memberVec ) {
				sb.append("<tr><td>").append(r.name)
				  .append("<td>").append(r.generation)
				  .append("<td>").append(r.myPhotoHash)
				  .append("<td>").append(r.chosenPhotoHash)
				  .append("</tr>\n");
			}
			sb.append("</table>");
			
			sb.append("<p><table><tr><th>Hash<th>Ref Count<th>File</tr>\n");
			RecordSet<PhotoRecord> photoVec = db.PHOTOTABLE.readAll();
			for ( PhotoRecord r : photoVec ) {
				sb.append("<tr><td>").append(r.hash)
				  .append("<td>").append(r.refCount)
				  .append("<td>").append(r.file)
				  .append("</tr>\n");
			}
			sb.append("</table>");
			
			sb.append("</body></html>");
			return sb.toString();

		} catch (Exception e) {
			Log.e(TAG, "Caught exception: " + e.getMessage());
			throw new DB461Exception("contact caught exception: "+ e.getMessage());
		}
		finally {
			if ( db != null ) db.discard();
		}
	}

	/**
	 * Checks db for consistency violations and tries to fix  them.
	 * Consistency requirements:
	 * <ul>
	 * <li> Every photo hash in community table should have a photo table entry
	 * <li> Ref count should be correct
	 * <li> If a photo table entry has a file name, the file should exist, and file's hash should correspond to the photo record key
	 * </ul>
	 */
	synchronized public void fixDB(File galleryDir) throws DB461Exception {
		SNetDB461 db = null;
		try {
			db = new SNetDB461(mDBName);
			db.checkAndFixDB(galleryDir);
		} catch (Exception e) {
			throw new DB461Exception("fixDB caught exception: "+ e.getMessage());
		}
		finally {
			if ( db != null ) db.discard();
		}
	}
	
	public String getPhotoFilename(DDNSFullName member, PhotoType type) {
		SNetDB461 db = null;
		try {
			db = new SNetDB461(mDBName);
			CommunityRecord cRecord = db.COMMUNITYTABLE.readOne(member.toString());
			if ( cRecord == null ) throw new Exception("Unknown member: " + member);
			int photoHash = type==PhotoType.MY_PHOTO ? cRecord.myPhotoHash : cRecord.chosenPhotoHash;
			if ( photoHash == 0 ) return null;
			PhotoRecord rRecord = db.PHOTOTABLE.readOne(photoHash);
			if ( rRecord == null || rRecord.file == null ) return null;
			return rRecord.file.getAbsolutePath();
		} catch (Exception e) {
			Log.e(TAG, "getPhotoFilename caught exception: "+ e.getMessage());
			e.printStackTrace();
			return null;
		}
		finally {
			if ( db != null ) db.discard();
		}
	}
	
	public DDNSFullName[] getAllMembers() {
		SNetDB461 db = null;
		try {
			db = new SNetDB461(mDBName);
			RecordSet<CommunityRecord> members = db.COMMUNITYTABLE.readAll();
			DDNSFullName[] result = new DDNSFullName[members.size()];
			for ( int i=0; i<result.length; i++) result[i] = members.get(i).name;
			return result;
		} catch (Exception e) {
			Log.e(TAG, "getAllMembers caught exception: "+ e.getMessage());
			return null;
		}
		finally {
			if ( db != null ) db.discard();
		}
	}
}
